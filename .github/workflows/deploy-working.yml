name: ğŸš€ Deploy - Simple and Working

on:
  workflow_dispatch:
    inputs:
      rebuild_images:
        description: 'Rebuild Docker images'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

env:
  AWS_REGION: us-east-1

jobs:
  load-config:
    name: ğŸ“‹ Load Configuration
    runs-on: ubuntu-latest
    outputs:
      core-ip: ${{ steps.load.outputs.core_public }}
      api-gateway-ip: ${{ steps.load.outputs.api_gateway_public }}
      db-ip: ${{ steps.load.outputs.db_public }}
      messaging-ip: ${{ steps.load.outputs.messaging_public }}
      reportes-ip: ${{ steps.load.outputs.reportes_public }}
      notificaciones-ip: ${{ steps.load.outputs.notificaciones_public }}
      analytics-ip: ${{ steps.load.outputs.analytics_public }}
      monitoring-ip: ${{ steps.load.outputs.monitoring_public }}
      frontend-ip: ${{ steps.load.outputs.frontend_public }}
      bastion-ip: ${{ steps.load.outputs.bastion_public }}

    steps:
      - uses: actions/checkout@v3
      - id: load
        run: |
          python3 << 'PYTHON'
          import json
          with open('config/instance_ips.json', 'r') as f:
              instances = json.load(f)
          mapping = {
              'EC2-CORE': 'core', 'EC2-API-Gateway': 'api_gateway', 'EC2-DB': 'db',
              'EC2-Messaging': 'messaging', 'EC2-Reportes': 'reportes',
              'EC2-Notificaciones': 'notificaciones', 'EC2-Analytics': 'analytics',
              'EC2-Monitoring': 'monitoring', 'EC2-Frontend': 'frontend', 'EC-Bastion': 'bastion'
          }
          for instance_name, output_name in mapping.items():
              if instance_name in instances:
                  print(f"::set-output name={output_name}_public::{instances[instance_name]['PublicIpAddress']}")
                  print(f"âœ… {instance_name}: {instances[instance_name]['PublicIpAddress']}")
          PYTHON

  deploy-core:
    name: "ğŸ³ EC2-CORE"
    needs: load-config
    runs-on: ubuntu-latest
    timeout-minutes: 25
    continue-on-error: true

    steps:
      - uses: actions/checkout@v3
      - uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      
      - run: |
          echo "ğŸ” Finding EC2-CORE instance ID..."
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=EC2-CORE" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)
          
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            echo "âŒ EC2-CORE not found or not running"
            exit 1
          fi
          
          echo "âœ… Found instance: $INSTANCE_ID"
          
          echo "ğŸ“¦ Creating deployment package..."
          tar czf /tmp/core-deploy.tar.gz \
            --exclude='node_modules' --exclude='.git' --exclude='dist' --exclude='build' \
            --exclude='.github' --exclude='tests' --exclude='config' \
            micro-auth micro-estudiantes micro-maestros shared-monitoring shared-config \
            shared-auth docker-compose.ec2-core.yml
          
          echo "ğŸ“¤ Uploading TAR to EC2-CORE..."
          aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "cd /tmp && rm -f core-deploy.tar.gz",
              "aws s3 cp /tmp/core-deploy.tar.gz s3://${{ secrets.S3_BUCKET }}/deployments/core/ 2>/dev/null || true"
            ]' \
            --output text > /dev/null
          
          # Alternative: Direct command via SSM
          echo "ğŸš€ Deploying to EC2-CORE..."
          aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "cd /tmp",
              "docker-compose -f docker-compose.ec2-core.yml down 2>/dev/null || true",
              "docker-compose -f docker-compose.ec2-core.yml up -d --no-build 2>&1 | tail -20",
              "sleep 5",
              "docker-compose -f docker-compose.ec2-core.yml ps",
              "echo DEPLOYMENT_COMPLETE"
            ]' \
            --output text > /tmp/ssm-command.txt
          
          COMMAND_ID=$(cat /tmp/ssm-command.txt | awk '{print $NF}')
          echo "Command ID: $COMMAND_ID"
          
          # Wait for command completion
          for i in {1..60}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "Status" \
              --output text 2>/dev/null || echo "Pending")
            
            if [ "$STATUS" = "Success" ]; then
              echo "âœ… EC2-CORE deployment successful"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query "StandardOutputContent" \
                --output text
              break
            elif [ "$STATUS" = "Failed" ]; then
              echo "âŒ EC2-CORE deployment failed"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query "StandardErrorContent" \
                --output text
              exit 1
            fi
            
            echo "â³ Waiting for deployment... ($i/60)"
            sleep 2
          done

  deploy-api-gateway:
    name: "ğŸŒ EC2-API-Gateway"
    needs: load-config
    runs-on: ubuntu-latest
    timeout-minutes: 15
    continue-on-error: true

    steps:
      - uses: actions/checkout@v3
      - uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      
      - run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=EC2-API-Gateway" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)
          
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            echo "âŒ EC2-API-Gateway not found"
            exit 1
          fi
          
          aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "cd /tmp && docker-compose -f docker-compose.api-gateway.yml down 2>/dev/null || true",
              "docker-compose -f docker-compose.api-gateway.yml up -d --no-build 2>&1 | tail -10",
              "sleep 3 && docker-compose -f docker-compose.api-gateway.yml ps"
            ]' \
            --output text > /tmp/ssm-command.txt
          
          COMMAND_ID=$(cat /tmp/ssm-command.txt | awk '{print $NF}')
          
          for i in {1..45}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "Status" \
              --output text 2>/dev/null || echo "Pending")
            
            if [ "$STATUS" = "Success" ]; then
              echo "âœ… API-Gateway deployed successfully"
              break
            elif [ "$STATUS" = "Failed" ]; then
              echo "âŒ API-Gateway deployment failed"
              exit 1
            fi
            
            sleep 2
          done

  deploy-db:
    name: "ğŸ—„ï¸  EC2-DB"
    needs: load-config
    runs-on: ubuntu-latest
    timeout-minutes: 20
    continue-on-error: true

    steps:
      - uses: actions/checkout@v3
      - uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      
      - run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=EC2-DB" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)
          
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            echo "âŒ EC2-DB not found"
            exit 1
          fi
          
          aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "cd /tmp && docker-compose -f docker-compose.ec2-db.yml down 2>/dev/null || true",
              "docker-compose -f docker-compose.ec2-db.yml up -d --no-build 2>&1 | tail -10",
              "sleep 5 && docker-compose -f docker-compose.ec2-db.yml ps"
            ]' \
            --output text > /tmp/ssm-command.txt
          
          COMMAND_ID=$(cat /tmp/ssm-command.txt | awk '{print $NF}')
          
          for i in {1..60}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "Status" \
              --output text 2>/dev/null || echo "Pending")
            
            if [ "$STATUS" = "Success" ]; then
              echo "âœ… EC2-DB deployed successfully"
              break
            elif [ "$STATUS" = "Failed" ]; then
              echo "âŒ EC2-DB deployment failed"
              exit 1
            fi
            
            sleep 2
          done

  deploy-messaging:
    name: "â±ï¸  EC2-Messaging"
    needs: load-config
    runs-on: ubuntu-latest
    timeout-minutes: 15
    continue-on-error: true

    steps:
      - uses: actions/checkout@v3
      - uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      
      - run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=EC2-Messaging" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)
          
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            echo "âŒ EC2-Messaging not found"
            exit 1
          fi
          
          aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "cd /tmp && docker-compose -f docker-compose.messaging.yml down 2>/dev/null || true",
              "docker-compose -f docker-compose.messaging.yml up -d --no-build 2>&1 | tail -10",
              "sleep 3 && docker-compose -f docker-compose.messaging.yml ps"
            ]' \
            --output text > /tmp/ssm-command.txt
          
          COMMAND_ID=$(cat /tmp/ssm-command.txt | awk '{print $NF}')
          
          for i in {1..45}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "Status" \
              --output text 2>/dev/null || echo "Pending")
            
            if [ "$STATUS" = "Success" ]; then
              echo "âœ… EC2-Messaging deployed successfully"
              break
            elif [ "$STATUS" = "Failed" ]; then
              echo "âŒ EC2-Messaging deployment failed"
              exit 1
            fi
            
            sleep 2
          done

  deploy-reportes:
    name: "ğŸ“„ EC2-Reportes"
    needs: load-config
    runs-on: ubuntu-latest
    timeout-minutes: 15
    continue-on-error: true

    steps:
      - uses: actions/checkout@v3
      - uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      
      - run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=EC2-Reportes" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)
          
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            echo "âŒ EC2-Reportes not found"
            exit 1
          fi
          
          aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "cd /tmp && docker-compose -f docker-compose.ec2-reportes.yml down 2>/dev/null || true",
              "docker-compose -f docker-compose.ec2-reportes.yml up -d --no-build 2>&1 | tail -10",
              "sleep 3 && docker-compose -f docker-compose.ec2-reportes.yml ps"
            ]' \
            --output text > /tmp/ssm-command.txt
          
          COMMAND_ID=$(cat /tmp/ssm-command.txt | awk '{print $NF}')
          
          for i in {1..45}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "Status" \
              --output text 2>/dev/null || echo "Pending")
            
            if [ "$STATUS" = "Success" ]; then
              echo "âœ… EC2-Reportes deployed successfully"
              break
            elif [ "$STATUS" = "Failed" ]; then
              echo "âŒ EC2-Reportes deployment failed"
              exit 1
            fi
            
            sleep 2
          done

  deploy-notificaciones:
    name: "ğŸ”” EC2-Notificaciones"
    needs: load-config
    runs-on: ubuntu-latest
    timeout-minutes: 15
    continue-on-error: true

    steps:
      - uses: actions/checkout@v3
      - uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      
      - run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=EC2-Notificaciones" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)
          
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            echo "âŒ EC2-Notificaciones not found"
            exit 1
          fi
          
          aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "cd /tmp && docker-compose -f docker-compose.ec2-notificaciones.yml down 2>/dev/null || true",
              "docker-compose -f docker-compose.ec2-notificaciones.yml up -d --no-build 2>&1 | tail -10",
              "sleep 3 && docker-compose -f docker-compose.ec2-notificaciones.yml ps"
            ]' \
            --output text > /tmp/ssm-command.txt
          
          COMMAND_ID=$(cat /tmp/ssm-command.txt | awk '{print $NF}')
          
          for i in {1..45}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "Status" \
              --output text 2>/dev/null || echo "Pending")
            
            if [ "$STATUS" = "Success" ]; then
              echo "âœ… EC2-Notificaciones deployed successfully"
              break
            elif [ "$STATUS" = "Failed" ]; then
              echo "âŒ EC2-Notificaciones deployment failed"
              exit 1
            fi
            
            sleep 2
          done

  deploy-analytics:
    name: "ğŸ“Š EC2-Analytics"
    needs: load-config
    runs-on: ubuntu-latest
    timeout-minutes: 15
    continue-on-error: true

    steps:
      - uses: actions/checkout@v3
      - uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      
      - run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=EC2-Analytics" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)
          
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            echo "âŒ EC2-Analytics not found"
            exit 1
          fi
          
          aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "cd /tmp && docker-compose -f docker-compose.ec2-analytics.yml down 2>/dev/null || true",
              "docker-compose -f docker-compose.ec2-analytics.yml up -d --no-build 2>&1 | tail -10",
              "sleep 3 && docker-compose -f docker-compose.ec2-analytics.yml ps"
            ]' \
            --output text > /tmp/ssm-command.txt
          
          COMMAND_ID=$(cat /tmp/ssm-command.txt | awk '{print $NF}')
          
          for i in {1..45}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "Status" \
              --output text 2>/dev/null || echo "Pending")
            
            if [ "$STATUS" = "Success" ]; then
              echo "âœ… EC2-Analytics deployed successfully"
              break
            elif [ "$STATUS" = "Failed" ]; then
              echo "âŒ EC2-Analytics deployment failed"
              exit 1
            fi
            
            sleep 2
          done

  deploy-monitoring:
    name: "ğŸ“ˆ EC2-Monitoring"
    needs: load-config
    runs-on: ubuntu-latest
    timeout-minutes: 15
    continue-on-error: true

    steps:
      - uses: actions/checkout@v3
      - uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      
      - run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=EC2-Monitoring" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)
          
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            echo "âŒ EC2-Monitoring not found"
            exit 1
          fi
          
          aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "cd /tmp && docker-compose -f docker-compose.ec2-monitoring.yml down 2>/dev/null || true",
              "docker-compose -f docker-compose.ec2-monitoring.yml up -d --no-build 2>&1 | tail -10",
              "sleep 3 && docker-compose -f docker-compose.ec2-monitoring.yml ps"
            ]' \
            --output text > /tmp/ssm-command.txt
          
          COMMAND_ID=$(cat /tmp/ssm-command.txt | awk '{print $NF}')
          
          for i in {1..45}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "Status" \
              --output text 2>/dev/null || echo "Pending")
            
            if [ "$STATUS" = "Success" ]; then
              echo "âœ… EC2-Monitoring deployed successfully"
              break
            elif [ "$STATUS" = "Failed" ]; then
              echo "âŒ EC2-Monitoring deployment failed"
              exit 1
            fi
            
            sleep 2
          done

  deploy-frontend:
    name: "ğŸ¨ EC2-Frontend"
    needs: load-config
    runs-on: ubuntu-latest
    timeout-minutes: 15
    continue-on-error: true

    steps:
      - uses: actions/checkout@v3
      - uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      
      - run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=EC2-Frontend" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)
          
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            echo "âŒ EC2-Frontend not found"
            exit 1
          fi
          
          aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "cd /tmp && docker-compose -f docker-compose.ec2-frontend.yml down 2>/dev/null || true",
              "docker-compose -f docker-compose.ec2-frontend.yml up -d --no-build 2>&1 | tail -10",
              "sleep 3 && docker-compose -f docker-compose.ec2-frontend.yml ps"
            ]' \
            --output text > /tmp/ssm-command.txt
          
          COMMAND_ID=$(cat /tmp/ssm-command.txt | awk '{print $NF}')
          
          for i in {1..45}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "Status" \
              --output text 2>/dev/null || echo "Pending")
            
            if [ "$STATUS" = "Success" ]; then
              echo "âœ… EC2-Frontend deployed successfully"
              break
            elif [ "$STATUS" = "Failed" ]; then
              echo "âŒ EC2-Frontend deployment failed"
              exit 1
            fi
            
            sleep 2
          done

  deploy-bastion:
    name: "ğŸ›¡ï¸  EC-Bastion"
    needs: load-config
    runs-on: ubuntu-latest
    timeout-minutes: 15
    continue-on-error: true

    steps:
      - uses: actions/checkout@v3
      - uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      
      - run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=EC-Bastion" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)
          
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            echo "âŒ EC-Bastion not found"
            exit 1
          fi
          
          aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "cd /tmp && docker-compose -f docker-compose.bastion.yml down 2>/dev/null || true",
              "docker-compose -f docker-compose.bastion.yml up -d --no-build 2>&1 | tail -10",
              "sleep 3 && docker-compose -f docker-compose.bastion.yml ps"
            ]' \
            --output text > /tmp/ssm-command.txt
          
          COMMAND_ID=$(cat /tmp/ssm-command.txt | awk '{print $NF}')
          
          for i in {1..45}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "Status" \
              --output text 2>/dev/null || echo "Pending")
            
            if [ "$STATUS" = "Success" ]; then
              echo "âœ… EC-Bastion deployed successfully"
              break
            elif [ "$STATUS" = "Failed" ]; then
              echo "âŒ EC-Bastion deployment failed"
              exit 1
            fi
            
            sleep 2
          done

  status:
    name: "âœ… Done"
    needs: [deploy-core, deploy-api-gateway, deploy-db, deploy-messaging, deploy-reportes, deploy-notificaciones, deploy-analytics, deploy-monitoring, deploy-frontend, deploy-bastion]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - run: echo "ğŸ‰ Deployment workflow complete!"
