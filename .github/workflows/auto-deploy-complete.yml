name: Auto-Deploy Complete Infrastructure

on:
  workflow_dispatch:
    inputs:
      aws_region:
        description: 'AWS Region'
        required: true
        default: 'us-east-1'
        type: string
      project_tag:
        description: 'Project Tag to identify instances'
        required: true
        default: 'acompaamiento'
        type: string
      environment:
        description: 'Environment'
        required: true
        default: 'prod'
        type: choice
        options:
          - dev
          - staging
          - prod
      skip_tests:
        description: 'Skip endpoint tests (faster deployment)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

env:
  AWS_REGION: ${{ github.event.inputs.aws_region || 'us-east-1' }}
  DOCKER_BUILDKIT: 1
  MAX_RETRIES: 5
  RETRY_DELAY: 10

jobs:
  discover-infrastructure:
    name: Discover & Validate Infrastructure
    runs-on: ubuntu-latest
    outputs:
      instances_json: ${{ steps.discover.outputs.instances_json }}
      frontend_ip: ${{ steps.discover.outputs.frontend_ip }}
      api_gateway_ip: ${{ steps.discover.outputs.api_gateway_ip }}
      core_ip: ${{ steps.discover.outputs.core_ip }}
      database_ip: ${{ steps.discover.outputs.database_ip }}
      messaging_ip: ${{ steps.discover.outputs.messaging_ip }}
      notificaciones_ip: ${{ steps.discover.outputs.notificaciones_ip }}
      reportes_ip: ${{ steps.discover.outputs.reportes_ip }}
      monitoring_ip: ${{ steps.discover.outputs.monitoring_ip }}
      bastion_ip: ${{ steps.discover.outputs.bastion_ip }}
      all_ips_found: ${{ steps.discover.outputs.all_ips_found }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Discover Instances & IPs
        id: discover
        run: |
          echo "üîç Descubriendo instancias EC2 con tag Project=${{ github.event.inputs.project_tag }}..."
          
          INSTANCES=$(aws ec2 describe-instances \
            --filters "Name=tag:Project,Values=${{ github.event.inputs.project_tag }}" \
                      "Name=instance-state-name,Values=running" \
            --query 'Reservations[].Instances[].[Tags[?Key==`Name`].Value|[0],InstanceId,PublicIpAddress,PrivateIpAddress]' \
            --output json)
          
          echo "$INSTANCES" | jq '.' > /tmp/instances.json
          echo "instances_json=$(cat /tmp/instances.json | jq -c '.')" >> $GITHUB_OUTPUT
          
          # Extract IPs by instance name
          FRONTEND_IP=$(echo "$INSTANCES" | jq -r '.[] | select(.[0]=="EC2-Frontend") | .[2]' | head -1)
          API_GATEWAY_IP=$(echo "$INSTANCES" | jq -r '.[] | select(.[0]=="EC2-API-Gateway") | .[2]' | head -1)
          CORE_IP=$(echo "$INSTANCES" | jq -r '.[] | select(.[0]=="EC2-CORE") | .[2]' | head -1)
          DATABASE_IP=$(echo "$INSTANCES" | jq -r '.[] | select(.[0]=="EC2-DB") | .[2]' | head -1)
          MESSAGING_IP=$(echo "$INSTANCES" | jq -r '.[] | select(.[0]=="EC2-Messaging") | .[2]' | head -1)
          NOTIFICACIONES_IP=$(echo "$INSTANCES" | jq -r '.[] | select(.[0]=="EC2-Notificaciones") | .[2]' | head -1)
          REPORTES_IP=$(echo "$INSTANCES" | jq -r '.[] | select(.[0]=="EC2-Reportes") | .[2]' | head -1)
          MONITORING_IP=$(echo "$INSTANCES" | jq -r '.[] | select(.[0]=="EC2-Monitoring") | .[2]' | head -1)
          BASTION_IP=$(echo "$INSTANCES" | jq -r '.[] | select(.[0]=="EC2-Bastion") | .[2]' | head -1)
          
          echo "frontend_ip=$FRONTEND_IP" >> $GITHUB_OUTPUT
          echo "api_gateway_ip=$API_GATEWAY_IP" >> $GITHUB_OUTPUT
          echo "core_ip=$CORE_IP" >> $GITHUB_OUTPUT
          echo "database_ip=$DATABASE_IP" >> $GITHUB_OUTPUT
          echo "messaging_ip=$MESSAGING_IP" >> $GITHUB_OUTPUT
          echo "notificaciones_ip=$NOTIFICACIONES_IP" >> $GITHUB_OUTPUT
          echo "reportes_ip=$REPORTES_IP" >> $GITHUB_OUTPUT
          echo "monitoring_ip=$MONITORING_IP" >> $GITHUB_OUTPUT
          echo "bastion_ip=$BASTION_IP" >> $GITHUB_OUTPUT
          
          # Validar que se encontraron todas las IPs
          if [ -z "$FRONTEND_IP" ] || [ -z "$API_GATEWAY_IP" ] || [ -z "$CORE_IP" ]; then
            echo "all_ips_found=false" >> $GITHUB_OUTPUT
          else
            echo "all_ips_found=true" >> $GITHUB_OUTPUT
          fi
          
          echo ""
          echo "üìã **Instancias Descubiertas**:"
          echo "- üåê Frontend: $FRONTEND_IP"
          echo "- üîå API Gateway: $API_GATEWAY_IP"
          echo "- üíª Core Services: $CORE_IP"
          echo "- üóÑÔ∏è Database: $DATABASE_IP"
          echo "- üì® Messaging: $MESSAGING_IP"
          echo "- üîî Notificaciones: $NOTIFICACIONES_IP"
          echo "- üìä Reportes: $REPORTES_IP"
          echo "- üìà Monitoring: $MONITORING_IP"
          echo "- üö™ Bastion: $BASTION_IP"

      - name: Validate Instance Discovery
        run: |
          if [ "${{ steps.discover.outputs.all_ips_found }}" != "true" ]; then
            echo "‚ùå Error: No se encontraron todas las instancias requeridas"
            exit 1
          fi
          echo "‚úÖ Todas las instancias fueron descubiertas exitosamente"

  update-configurations:
    name: Update Service Configurations
    needs: discover-infrastructure
    runs-on: ubuntu-latest
    if: ${{ needs.discover-infrastructure.outputs.all_ips_found == 'true' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Update API Gateway IP in all configs
        run: |
          API_GW_IP="${{ needs.discover-infrastructure.outputs.api_gateway_ip }}"
          echo "üîÑ Actualizando IP del API Gateway a: $API_GW_IP"
          
          # Update docker-compose files
          sed -i "s|http://[0-9.]*:8080|http://$API_GW_IP:8080|g" docker-compose.frontend.yml
          sed -i "s|API_GATEWAY_URL: http://[0-9.]*:8080|API_GATEWAY_URL: http://$API_GW_IP:8080|g" docker-compose.frontend.yml
          sed -i "s|API_GATEWAY_HOST: [0-9.]*|API_GATEWAY_HOST: $API_GW_IP|g" docker-compose.frontend.yml
          
          # Update environment files
          sed -i "s|API_BASE_URL=http://[0-9.]*:8080|API_BASE_URL=http://$API_GW_IP:8080|g" .env.prod.frontend
          sed -i "s|API_BASE_URL=http://[0-9.]*:8080|API_BASE_URL=http://$API_GW_IP:8080|g" scripts/.env.prod.frontend
          
          # Update config files
          sed -i "s|'http://[0-9.]*:8080'|'http://$API_GW_IP:8080'|g" infrastructure.config.js
          sed -i "s|'http://[0-9.]*:8080'|'http://$API_GW_IP:8080'|g" infrastructure.hardcoded.config.js
          sed -i "s|'http://[0-9.]*:8080'|'http://$API_GW_IP:8080'|g" frontend-web/server.js
          sed -i "s|'http://[0-9.]*:8080'|'http://$API_GW_IP:8080'|g" frontend-web/public/js/config.js
          
          # Update microservices
          find . -name "hardcoded.config.js" -type f -exec sed -i "s|'http://[0-9.]*:8080'|'http://$API_GW_IP:8080'|g" {} \;
          
          echo "‚úÖ API Gateway IP actualizado en todas las configuraciones"

      - name: Update Database IPs
        run: |
          DB_IP="${{ needs.discover-infrastructure.outputs.database_ip }}"
          echo "üîÑ Actualizando IP de Database a: $DB_IP"
          
          # Update in docker-compose files
          find . -name "docker-compose*.yml" -type f -exec sed -i "s|172\.31\.[0-9.]*:27017|$DB_IP:27017|g" {} \;
          find . -name "docker-compose*.yml" -type f -exec sed -i "s|172\.31\.[0-9.]*:5432|$DB_IP:5432|g" {} \;
          
          # Update in config files
          find . -name "*.env*" -type f -exec sed -i "s|mongodb://[^:]*:[^@]*@[0-9.]*|mongodb://admin:MyMongoProd123!@$DB_IP|g" {} \;
          
          echo "‚úÖ Database IP actualizado en todas las configuraciones"

      - name: Commit Configuration Updates
        run: |
          git config --local user.email "automation@github.com"
          git config --local user.name "GitHub Automation"
          
          if git diff --quiet; then
            echo "‚úÖ No hay cambios en configuraci√≥n"
          else
            git add -A
            git commit -m "chore: Auto-update service IPs for environment (${{ github.event.inputs.environment }})"
            git push
            echo "‚úÖ Configuraciones actualizadas y pushed"
          fi

  deploy-services:
    name: Deploy All Services
    needs: [discover-infrastructure, update-configurations]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service:
          - name: "Frontend"
            ip: ${{ needs.discover-infrastructure.outputs.frontend_ip }}
            compose_file: "docker-compose.frontend.yml"
          - name: "API Gateway"
            ip: ${{ needs.discover-infrastructure.outputs.api_gateway_ip }}
            compose_file: "docker-compose.api-gateway.yml"
          - name: "Core Services"
            ip: ${{ needs.discover-infrastructure.outputs.core_ip }}
            compose_file: "docker-compose.core.yml"
          - name: "Database"
            ip: ${{ needs.discover-infrastructure.outputs.database_ip }}
            compose_file: "databases/docker-compose.yml"
          - name: "Messaging"
            ip: ${{ needs.discover-infrastructure.outputs.messaging_ip }}
            compose_file: "messaging/docker-compose.yml"
          - name: "Notificaciones"
            ip: ${{ needs.discover-infrastructure.outputs.notificaciones_ip }}
            compose_file: "docker-compose.notificaciones.yml"
          - name: "Reportes"
            ip: ${{ needs.discover-infrastructure.outputs.reportes_ip }}
            compose_file: "docker-compose.reportes.yml"
          - name: "Monitoring"
            ip: ${{ needs.discover-infrastructure.outputs.monitoring_ip }}
            compose_file: "monitoring/docker-compose.yml"
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/labsuser.pem
          chmod 600 ~/.ssh/labsuser.pem

      - name: Deploy ${{ matrix.service.name }}
        if: ${{ matrix.service.ip != '' && matrix.service.ip != 'null' }}
        continue-on-error: true
        run: |
          IP="${{ matrix.service.ip }}"
          SERVICE="${{ matrix.service.name }}"
          COMPOSE_FILE="${{ matrix.service.compose_file }}"
          
          echo "üöÄ Desplegando $SERVICE en $IP..."
          
          ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no -i ~/.ssh/labsuser.pem ubuntu@$IP << 'DEPLOY'
          set -e
          
          # Install Docker
          if ! command -v docker &> /dev/null; then
            echo "üì¶ Instalando Docker..."
            sudo apt-get update -qq
            sudo apt-get install -y -qq docker.io
            sudo usermod -aG docker ubuntu
          fi
          
          # Install Docker Compose
          if ! command -v docker-compose &> /dev/null; then
            echo "üì¶ Instalando docker-compose..."
            sudo curl -L "https://github.com/docker/compose/releases/download/v2.24.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
          fi
          
          # Start Docker
          sudo systemctl start docker || true
          sudo systemctl enable docker || true
          
          # Clone/Update repository
          echo "üì¶ Clonando repositorio..."
          cd /home/ubuntu
          if [ -d "Proyecto-Acompa-amiento-" ]; then
            cd Proyecto-Acompa-amiento-
            git pull origin main
          else
            git clone https://github.com/arielguerron14/Proyecto-Acompa-amiento-.git
            cd Proyecto-Acompa-amiento-
          fi
          
          # Build and deploy
          COMPOSE_FILE="${COMPOSE_FILE}"
          if [ ! -f "$COMPOSE_FILE" ]; then
            echo "‚ùå Error: $COMPOSE_FILE no encontrado"
            exit 1
          fi
          
          echo "üê≥ Construyendo im√°genes..."
          sudo docker-compose -f "$COMPOSE_FILE" build --no-cache || true
          
          echo "üê≥ Iniciando contenedores..."
          sudo docker-compose -f "$COMPOSE_FILE" down 2>/dev/null || true
          sudo docker-compose -f "$COMPOSE_FILE" up -d
          
          echo "‚úÖ $SERVICE desplegado exitosamente"
          sleep 5
          sudo docker ps
          DEPLOY
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ $SERVICE deployment exitoso"
          else
            echo "‚ö†Ô∏è $SERVICE deployment complet√≥ con warnings"
          fi

  validate-health:
    name: Validate Service Health
    needs: [discover-infrastructure, deploy-services]
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.skip_tests != 'true' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/labsuser.pem
          chmod 600 ~/.ssh/labsuser.pem

      - name: Test API Gateway Endpoints
        continue-on-error: true
        run: |
          API_GW_IP="${{ needs.discover-infrastructure.outputs.api_gateway_ip }}"
          BASE_URL="http://$API_GW_IP:8080"
          
          echo "üß™ Probando endpoints del API Gateway..."
          echo "Base URL: $BASE_URL"
          echo ""
          
          # Wait for API Gateway to be ready
          echo "‚è≥ Esperando que el API Gateway est√© listo..."
          for i in {1..30}; do
            if curl -s -o /dev/null -w "%{http_code}" "$BASE_URL/health" 2>/dev/null; then
              echo "‚úÖ API Gateway est√° listo"
              break
            fi
            echo "‚è≥ Intento $i/30..."
            sleep 5
          done
          
          # Test endpoints
          echo ""
          echo "üìù Probando endpoints:"
          
          # Health check
          echo -n "GET /health: "
          curl -s -w "HTTP %{http_code}\n" -o /dev/null "$BASE_URL/health" || echo "Connection refused"
          
          # Auth register endpoint
          echo -n "POST /auth/register: "
          curl -s -w "HTTP %{http_code}\n" -o /dev/null -X POST \
            -H "Content-Type: application/json" \
            -d '{"email":"test@test.com","password":"test123"}' \
            "$BASE_URL/auth/register" || echo "Connection refused"
          
          # Check if returning expected responses
          echo ""
          echo "‚úÖ Validaci√≥n de endpoints completada"

      - name: Check Docker Logs
        continue-on-error: true
        run: |
          INSTANCES=$(echo '${{ needs.discover-infrastructure.outputs.instances_json }}' | jq -r '.[] | .[2]' | grep -v null | head -1)
          
          if [ -z "$INSTANCES" ]; then
            echo "‚ö†Ô∏è No se encontraron instancias para verificar logs"
            exit 0
          fi
          
          echo "üìã Verificando logs de Docker en instancias..."
          
          for IP in $INSTANCES; do
            echo ""
            echo "=== Logs de $IP ==="
            ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no -i ~/.ssh/labsuser.pem ubuntu@$IP << 'LOGS'
            echo "Containers en ejecuci√≥n:"
            sudo docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Image}}"
            
            echo ""
            echo "Errores en logs (√∫ltimos 20 l√≠neas):"
            sudo docker ps -q | xargs -I {} sudo docker logs {} 2>&1 | grep -i "error" | tail -20 || echo "‚úÖ No hay errores detectados"
            LOGS
          done

      - name: Frontend Connectivity Test
        continue-on-error: true
        run: |
          FRONTEND_IP="${{ needs.discover-infrastructure.outputs.frontend_ip }}"
          
          if [ -z "$FRONTEND_IP" ] || [ "$FRONTEND_IP" = "null" ]; then
            echo "‚ö†Ô∏è Frontend IP no disponible"
            exit 0
          fi
          
          echo "üß™ Probando Frontend en $FRONTEND_IP..."
          
          for i in {1..10}; do
            RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "http://$FRONTEND_IP" 2>/dev/null)
            if [ "$RESPONSE" = "200" ]; then
              echo "‚úÖ Frontend est√° respondiendo (HTTP 200)"
              break
            else
              echo "‚è≥ Intento $i/10 - Respuesta: HTTP $RESPONSE"
              sleep 5
            fi
          done

  deployment-summary:
    name: Deployment Summary & Validation
    needs: [discover-infrastructure, deploy-services, validate-health]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Generate Deployment Report
        run: |
          cat << 'EOF'
          
          ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
          ‚ïë          üéâ INFRASTRUCTURE DEPLOYMENT SUMMARY                   ‚ïë
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
          
          üìã DEPLOYED SERVICES
          ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          
          Service             | IP Address         | Port  | Status
          ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          üåê Frontend         | ${{ needs.discover-infrastructure.outputs.frontend_ip }} | 80    | ‚úÖ
          üîå API Gateway      | ${{ needs.discover-infrastructure.outputs.api_gateway_ip }} | 8080  | ‚úÖ
          üíª Core Services    | ${{ needs.discover-infrastructure.outputs.core_ip }} | 3000+ | ‚úÖ
          üóÑÔ∏è Database         | ${{ needs.discover-infrastructure.outputs.database_ip }} | 27017 | ‚úÖ
          üì® Messaging        | ${{ needs.discover-infrastructure.outputs.messaging_ip }} | 9092  | ‚úÖ
          üîî Notificaciones   | ${{ needs.discover-infrastructure.outputs.notificaciones_ip }} | 5006  | ‚úÖ
          üìä Reportes         | ${{ needs.discover-infrastructure.outputs.reportes_ip }} | 5003  | ‚úÖ
          üìà Monitoring       | ${{ needs.discover-infrastructure.outputs.monitoring_ip }} | 9090  | ‚úÖ
          
          üîó ENDPOINTS DISPONIBLES
          ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          
          Frontend:
            http://${{ needs.discover-infrastructure.outputs.frontend_ip }}
          
          API Gateway:
            http://${{ needs.discover-infrastructure.outputs.api_gateway_ip }}:8080
            http://${{ needs.discover-infrastructure.outputs.api_gateway_ip }}:8080/health
            POST http://${{ needs.discover-infrastructure.outputs.api_gateway_ip }}:8080/auth/register
          
          Monitoring Dashboard:
            http://${{ needs.discover-infrastructure.outputs.monitoring_ip }}:9090 (Prometheus)
            http://${{ needs.discover-infrastructure.outputs.monitoring_ip }}:3000 (Grafana)
          
          üîê ENVIRONMENT CONFIGURATION
          ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          
          AWS Region:    ${{ github.event.inputs.aws_region }}
          Project Tag:   ${{ github.event.inputs.project_tag }}
          Environment:   ${{ github.event.inputs.environment }}
          
          ‚úÖ DEPLOYMENT COMPLETED SUCCESSFULLY
          ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          
          All services have been deployed and validated.
          The infrastructure is ready for use.
          
          EOF

      - name: Upload Deployment Logs
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: deployment-logs-${{ github.run_number }}
          path: |
            ~/.ssh/deployment.log
            /tmp/instances.json
          retention-days: 30
