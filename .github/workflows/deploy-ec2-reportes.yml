name: Deploy EC2-Reportes Services (micro-reportes-estudiantes, micro-reportes-maestros)

on:
  workflow_dispatch:
    inputs:
      instance_name:
        description: 'EC2 Instance name to deploy (default: EC2-Reportes)'
        required: false
        default: 'EC2-Reportes'
      skip_verification:
        description: 'Skip health verification (true/false)'
        required: false
        default: 'false'

env:
  INSTANCE_NAME: ${{ github.event.inputs.instance_name || 'EC2-Reportes' }}
  INSTANCE_USER: ubuntu
  REPO_URL: https://github.com/arielguerron14/Proyecto-Acompa-amiento-.git
  AWS_REGION: us-east-1

jobs:
  deploy-reportes-services:
    runs-on: ubuntu-latest
    name: Deploy Reportes Services to EC2-Reportes

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Discover EC2 instances and IPs
      run: |
        echo "üîç Discovering EC2 instances..."

        INSTANCE_INFO=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=${{ env.INSTANCE_NAME }}" \
                    "Name=instance-state-name,Values=running" \
          --query 'Reservations[].Instances[].[PublicIpAddress, PrivateIpAddress, InstanceId, InstanceType, Tags[?Key==`Name`].Value|[0]]' \
          --output json)

        PUBLIC_IP=$(echo "$INSTANCE_INFO" | jq -r '.[0][0]')
        PRIVATE_IP=$(echo "$INSTANCE_INFO" | jq -r '.[0][1]')
        INSTANCE_ID=$(echo "$INSTANCE_INFO" | jq -r '.[0][2]')
        INSTANCE_TYPE=$(echo "$INSTANCE_INFO" | jq -r '.[0][3]')

        echo "INSTANCE_PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV
        echo "INSTANCE_PRIVATE_IP=$PRIVATE_IP" >> $GITHUB_ENV
        echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
        echo "INSTANCE_TYPE=$INSTANCE_TYPE" >> $GITHUB_ENV

        if [ -z "$PUBLIC_IP" ] || [ "$PUBLIC_IP" == "null" ]; then
          echo "‚ùå ERROR: Could not find instance with name: ${{ env.INSTANCE_NAME }}"
          aws ec2 describe-instances \
            --filters "Name=instance-state-name,Values=running" \
            --query 'Reservations[].Instances[].[InstanceId, InstanceType, PublicIpAddress, Tags[?Key==`Name`].Value|[0]]' \
            --output table
          exit 1
        fi

        echo "‚úÖ Instance discovered:" && \
        echo "   Name:       ${{ env.INSTANCE_NAME }}" && \
        echo "   ID:         $INSTANCE_ID" && \
        echo "   Type:       $INSTANCE_TYPE" && \
        echo "   Public IP:  $PUBLIC_IP" && \
        echo "   Private IP: $PRIVATE_IP"

    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ env.INSTANCE_PUBLIC_IP }} >> ~/.ssh/known_hosts 2>/dev/null || true

    - name: Verify SSH connection
      run: |
        ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no ${{ env.INSTANCE_USER }}@${{ env.INSTANCE_PUBLIC_IP }} "echo '‚úÖ SSH connection successful'; whoami"

    - name: Fix network configuration (VPC routes and security groups)
      run: |
        echo "üîß Checking and fixing network configuration for EC2-Reportes..."
        
        # Get instance details
        INSTANCE_INFO=$(aws ec2 describe-instances \
          --instance-ids ${{ env.INSTANCE_ID }} \
          --region ${{ env.AWS_REGION }} \
          --query 'Reservations[0].Instances[0]')
        
        SG_ID=$(echo "$INSTANCE_INFO" | jq -r '.SecurityGroups[0].GroupId')
        SUBNET_ID=$(echo "$INSTANCE_INFO" | jq -r '.SubnetId')
        
        echo "Security Group: $SG_ID"
        echo "Subnet: $SUBNET_ID"
        
        # Get VPC and IGW
        VPC_ID=$(aws ec2 describe-subnets \
          --subnet-ids "$SUBNET_ID" \
          --region ${{ env.AWS_REGION }} \
          --query 'Subnets[0].VpcId' \
          --output text)
        
        IGW_ID=$(aws ec2 describe-internet-gateways \
          --region ${{ env.AWS_REGION }} \
          --filters "Name=attachment.vpc-id,Values=$VPC_ID" \
          --query 'InternetGateways[0].InternetGatewayId' \
          --output text)
        
        echo "VPC: $VPC_ID | IGW: $IGW_ID"
        
        # Get route table
        RT_ID=$(aws ec2 describe-route-tables \
          --region ${{ env.AWS_REGION }} \
          --filters "Name=association.subnet-id,Values=$SUBNET_ID" \
          --query 'RouteTables[0].RouteTableId' \
          --output text 2>/dev/null || echo "")
        
        if [ -z "$RT_ID" ] || [ "$RT_ID" = "None" ]; then
          RT_ID=$(aws ec2 describe-route-tables \
            --region ${{ env.AWS_REGION }} \
            --filters "Name=vpc-id,Values=$VPC_ID" "Name=association.main,Values=true" \
            --query 'RouteTables[0].RouteTableId' \
            --output text)
        fi
        
        echo "Route Table: $RT_ID"
        
        # Check and add default route
        ROUTE_EXISTS=$(aws ec2 describe-route-tables \
          --route-table-ids "$RT_ID" \
          --region ${{ env.AWS_REGION }} \
          --query "RouteTables[0].Routes[?DestinationCidrBlock=='0.0.0.0/0'].GatewayId" \
          --output text 2>/dev/null || echo "")
        
        if [ -z "$ROUTE_EXISTS" ] || [ "$ROUTE_EXISTS" = "None" ]; then
          echo "‚ö†Ô∏è  Adding default route 0.0.0.0/0 ‚Üí $IGW_ID"
          aws ec2 create-route \
            --route-table-id "$RT_ID" \
            --destination-cidr-block 0.0.0.0/0 \
            --gateway-id "$IGW_ID" \
            --region ${{ env.AWS_REGION }} 2>&1 || echo "Route may exist"
        else
          echo "‚úÖ Default route exists ‚Üí $ROUTE_EXISTS"
        fi
        
        # Check and fix security group egress rules
        echo "Checking security group egress rules..."
        EGRESS_RULES=$(aws ec2 describe-security-groups \
          --group-ids "$SG_ID" \
          --region ${{ env.AWS_REGION }} \
          --query 'SecurityGroups[0].IpPermissionsEgress' \
          --output json)
        
        ALL_TRAFFIC=$(echo "$EGRESS_RULES" | grep -c '\"IpProtocol\": \"-1\"' || echo "0")
        
        if [ "$ALL_TRAFFIC" -gt 0 ]; then
          echo "‚úÖ Security group allows all outbound traffic"
        else
          echo "‚ö†Ô∏è  Adding egress rules for HTTPS, HTTP, and DNS..."
          aws ec2 authorize-security-group-egress --group-id "$SG_ID" --protocol tcp --port 443 --cidr 0.0.0.0/0 --region ${{ env.AWS_REGION }} 2>&1 || true
          aws ec2 authorize-security-group-egress --group-id "$SG_ID" --protocol tcp --port 80 --cidr 0.0.0.0/0 --region ${{ env.AWS_REGION }} 2>&1 || true
          aws ec2 authorize-security-group-egress --group-id "$SG_ID" --protocol udp --port 53 --cidr 0.0.0.0/0 --region ${{ env.AWS_REGION }} 2>&1 || true
          aws ec2 authorize-security-group-egress --group-id "$SG_ID" --protocol tcp --port 53 --cidr 0.0.0.0/0 --region ${{ env.AWS_REGION }} 2>&1 || true
          echo "‚úÖ Egress rules added"
        fi
        
        echo "‚è≥ Waiting 60 seconds for network changes to propagate..."
        sleep 60
    
    - name: Discover dependent instances IPs
      run: |
        echo "üîç Discovering IPs of dependency instances..."
        
        # Discover EC2-DB instance (for mongo/postgres)
        DB_INSTANCE=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=EC2-DB" \
                    "Name=instance-state-name,Values=running" \
          --query 'Reservations[0].Instances[0].PrivateIpAddress' \
          --output text)
        
        # Discover EC2-Messaging instance (for kafka/rabbitmq)
        MESSAGING_INSTANCE=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=EC2-Messaging" \
                    "Name=instance-state-name,Values=running" \
          --query 'Reservations[0].Instances[0].PrivateIpAddress' \
          --output text)
        
        if [ ! -z "$DB_INSTANCE" ] && [ "$DB_INSTANCE" != "None" ]; then
          echo "DB_HOST=$DB_INSTANCE" >> $GITHUB_ENV
          echo "‚úÖ Found EC2-DB at: $DB_INSTANCE"
        else
          echo "‚ö†Ô∏è  EC2-DB not found, using local mongo/postgres"
          echo "DB_HOST=mongo" >> $GITHUB_ENV
        fi
        
        if [ ! -z "$MESSAGING_INSTANCE" ] && [ "$MESSAGING_INSTANCE" != "None" ]; then
          echo "MESSAGING_HOST=$MESSAGING_INSTANCE" >> $GITHUB_ENV
          echo "‚úÖ Found EC2-Messaging at: $MESSAGING_INSTANCE"
        else
          echo "‚ö†Ô∏è  EC2-Messaging not found, using local kafka"
          echo "MESSAGING_HOST=kafka" >> $GITHUB_ENV
        fi

    - name: Detect instance and prepare environment
      run: |
        echo "Instance Name:   ${{ env.INSTANCE_NAME }}"
        echo "Instance ID:     ${{ env.INSTANCE_ID }}"
        echo "Instance Type:   ${{ env.INSTANCE_TYPE }}"
        echo "Public IP:       ${{ env.INSTANCE_PUBLIC_IP }}"
        echo "Private IP:      ${{ env.INSTANCE_PRIVATE_IP }}"
        echo "Services:        micro-reportes-estudiantes, micro-reportes-maestros (deps: mongo, postgres, kafka, zookeeper)"
        echo "DB Host:         ${{ env.DB_HOST }}"
        echo "Messaging Host:  ${{ env.MESSAGING_HOST }}"

    - name: Deploy and configure reportes services
      run: |
        ssh -o StrictHostKeyChecking=no ${{ env.INSTANCE_USER }}@${{ env.INSTANCE_PUBLIC_IP }} << 'EOF'
        set -e

        echo "=== EC2-Reportes Deployment Started ==="
        echo "Hostname: $(hostname)"
        echo "IP Address: $(hostname -I)"
        
        # Test DNS and fix if needed
        echo "üß™ Testing DNS resolution..."
        if ! nslookup -querytype=A github.com 8.8.8.8 >/dev/null 2>&1; then
          echo "‚ö†Ô∏è  DNS not working, adding AWS DNS server..."
          if ! grep -q "169.254.169.253" /etc/resolv.conf 2>/dev/null; then
            echo "nameserver 169.254.169.253" | sudo tee -a /etc/resolv.conf
          fi
        else
          echo "‚úÖ DNS working"
        fi

        echo "üì¶ Updating system packages..."
        sudo apt-get update -qq || true

        echo "üê≥ Checking Docker installation..."
        if ! command -v docker &> /dev/null; then
          sudo apt-get install -y docker.io docker-compose git
          sudo systemctl enable docker
          sudo systemctl start docker
          sudo usermod -aG docker ubuntu
        fi

        echo "üê≥ Setting up Docker Compose..."
        if docker compose version &> /dev/null 2>&1; then
          export DC="docker compose"
        elif command -v docker-compose &> /dev/null; then
          export DC="docker-compose"
        else
          sudo apt-get install -y docker-compose-plugin 2>/dev/null || {
            curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /tmp/docker-compose
            sudo mv /tmp/docker-compose /usr/local/bin/
            sudo chmod +x /usr/local/bin/docker-compose
            export DC="docker-compose"
          }
        fi
        echo "‚úÖ Using: $DC"

        if [ ! -d ~/projeto-acompanamiento ]; then
          cd ~ && git clone ${{ env.REPO_URL }} projeto-acompanamiento
        else
          cd ~/projeto-acompanamiento && git pull origin main
        fi

        cd ~/projeto-acompanamiento

        echo "üî® Building reportes microservices and deps images..."
        $DC build zookeeper kafka mongo postgres micro-reportes-estudiantes micro-reportes-maestros --no-cache 2>&1 | tail -20 || echo "‚ö†Ô∏è Build notes"

        echo "üöÄ Starting reportes services (with deps)..."
        
        # Create .env.local with proper configuration
        echo "üìù Creating .env.local for reportes services..."
        echo "NODE_ENV=production" > .env.local
        echo "DOCKER_DEPLOYMENT=true" >> .env.local
        echo "MONGODB_URI=mongodb://root:example@mongo:27017/admin?authSource=admin" >> .env.local
        echo "KAFKA_BROKERS=kafka:9092" >> .env.local
        echo "RABBITMQ_URL=amqp://guest:guest@rabbitmq:5672" >> .env.local
        echo "POSTGRES_HOST=postgres" >> .env.local
        echo "POSTGRES_PORT=5432" >> .env.local
        echo "POSTGRES_USER=postgres" >> .env.local
        echo "POSTGRES_PASSWORD=example" >> .env.local
        echo "POSTGRES_DB=acompanamiento" >> .env.local

        # Stop old services to force recreation
        $DC down 2>/dev/null || true
        sleep 3
        
        # Start services - ports configuration enables cross-instance access
        $DC up -d zookeeper kafka mongo postgres
        sleep 15
        $DC up -d micro-reportes-estudiantes micro-reportes-maestros
        
        echo "üì° Reportes services started with exposed ports for cross-instance communication..."

        echo "‚è≥ Waiting for services to initialize (40 seconds)..."
        sleep 40

        echo "‚úÖ Current container status:" && $DC ps
        echo "=== EC2-Reportes Deployment Completed ==="
        EOF

    - name: Health check - micro-reportes-estudiantes
      if: ${{ github.event.inputs.skip_verification != 'true' }}
      continue-on-error: true
      run: |
        echo "üîç Checking micro-reportes-estudiantes container..."
        ssh -o StrictHostKeyChecking=no ${{ env.INSTANCE_USER }}@${{ env.INSTANCE_PUBLIC_IP }} << 'EOF' || true
        cd ~/projeto-acompanamiento
        if docker compose version &>/dev/null 2>&1; then DC="docker compose"; elif command -v docker-compose &>/dev/null 2>&1; then DC="docker-compose"; else exit 0; fi
        $DC ps | grep micro-reportes-estudiantes || true
        EOF

    - name: Health check - micro-reportes-maestros
      if: ${{ github.event.inputs.skip_verification != 'true' }}
      continue-on-error: true
      run: |
        echo "üîç Checking micro-reportes-maestros container..."
        ssh -o StrictHostKeyChecking=no ${{ env.INSTANCE_USER }}@${{ env.INSTANCE_PUBLIC_IP }} << 'EOF' || true
        cd ~/projeto-acompanamiento
        if docker compose version &>/dev/null 2>&1; then DC="docker compose"; elif command -v docker-compose &>/dev/null 2>&1; then DC="docker-compose"; else exit 0; fi
        $DC ps | grep micro-reportes-maestros || true
        EOF

    - name: Verify all services and generate report
      if: always()
      run: |
        echo "üìä Final service status on ${{ env.INSTANCE_NAME }}:"
        ssh -o StrictHostKeyChecking=no ${{ env.INSTANCE_USER }}@${{ env.INSTANCE_PUBLIC_IP }} << 'EOF' || true
        cd ~/projeto-acompanamiento

        if docker compose version &>/dev/null 2>&1; then
          DC="docker compose"
        elif command -v docker-compose &>/dev/null 2>&1; then
          DC="docker-compose"
        else
          DC="docker compose"
        fi

        echo "=== Docker Containers Status ==="
        $DC ps

        echo -e "\n=== Reportes Services (expected running) ==="
        echo "- zookeeper"
        echo "- kafka"
        echo "- mongo"
        echo "- postgres"
        echo "- micro-reportes-estudiantes"
        echo "- micro-reportes-maestros"

        echo -e "\n‚úÖ EC2-Reportes deployment completed"
        EOF
