name: Deploy to EC2 (Fixed)

on:
  workflow_dispatch:
    inputs:
      instance:
        description: 'Instance to deploy'
        required: true
        default: 'EC2_CORE'
        type: choice
        options:
          - EC2_CORE
          - EC2_DB
          - EC2_API_GATEWAY
          - EC2_FRONTEND
          - EC2_MESSAGING
          - EC2_MONITORING
      rebuild_docker:
        description: 'Rebuild Docker images'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      build_location:
        description: 'Where to build images'
        required: false
        default: 'ec2'
        type: choice
        options:
          - 'ec2'
          - 'github'
      environment:
        description: 'Environment'
        required: true
        default: 'prod'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  AWS_REGION: us-east-1
  DOCKER_BUILDKIT: 1

jobs:
  deploy-ec2:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    permissions:
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set defaults for missing inputs
        id: defaults
        run: |
          REBUILD_DOCKER="${{ github.event.inputs.rebuild_docker || 'true' }}"
          BUILD_LOCATION="${{ github.event.inputs.build_location || 'ec2' }}"
          ENVIRONMENT="${{ github.event.inputs.environment || 'prod' }}"
          echo "rebuild_docker=${REBUILD_DOCKER}" >> $GITHUB_OUTPUT
          echo "build_location=${BUILD_LOCATION}" >> $GITHUB_OUTPUT
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          echo "REBUILD_DOCKER=${REBUILD_DOCKER}" >> $GITHUB_ENV
          echo "BUILD_LOCATION=${BUILD_LOCATION}" >> $GITHUB_ENV
          echo "ENVIRONMENT=${ENVIRONMENT}" >> $GITHUB_ENV
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN || '' }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Get EC2 IP (Dynamic Discovery with AWS Tags)
        id: get-ip
        run: |
          INSTANCE="${{ github.event.inputs.instance }}"
          
          # Map instance name to EXACT EC2 tag name
          case "$INSTANCE" in
            EC2_CORE)
              TAG_NAME="EC2-CORE"
              ;;
            EC2_DB)
              TAG_NAME="EC2-DB"
              ;;
            EC2_API_GATEWAY)
              TAG_NAME="EC2-API-Gateway"
              ;;
            EC2_FRONTEND)
              TAG_NAME="EC2-Frontend"
              ;;
            EC2_MESSAGING)
              TAG_NAME="EC2-Messaging"
              ;;
            EC2_MONITORING)
              TAG_NAME="EC2-Monitoring"
              ;;
            *)
              echo "‚ùå Unknown instance type: $INSTANCE"
              exit 1
              ;;
          esac
          
          echo "üîç Discovering EC2 instance with tag Name=$TAG_NAME"
          
          # Configure AWS credentials first
          export AWS_REGION="${{ env.AWS_REGION }}"
          
          # Query EC2 for running instance with EXACT tag name match
          INSTANCE_DATA=$(aws ec2 describe-instances \
            --region $AWS_REGION \
            --filters "Name=instance-state-name,Values=running" "Name=tag:Name,Values=$TAG_NAME" \
            --query 'Reservations[0].Instances[0]' \
            --output json 2>/dev/null)
          
          if [ "$INSTANCE_DATA" = "null" ] || [ -z "$INSTANCE_DATA" ]; then
            echo "‚ùå ERROR: Instance with tag Name=$TAG_NAME not found or not running"
            echo "‚ö†Ô∏è Check AWS credentials or instance status"
            # Fallback to direct IP (for backwards compatibility, but this should not happen)
            case "$INSTANCE" in
              EC2_CORE)
                IP="3.236.51.29"
                ;;
              *)
                IP="0.0.0.0"
                ;;
            esac
          else
            IP=$(echo "$INSTANCE_DATA" | jq -r '.PublicIpAddress // empty')
            INSTANCE_NAME=$(echo "$INSTANCE_DATA" | jq -r '.Tags[] | select(.Key=="Name") | .Value' | head -1)
            echo "‚úÖ Found: $INSTANCE_NAME at $IP"
          fi
          
          if [ -z "$IP" ] || [ "$IP" = "null" ]; then
            echo "‚ùå ERROR: Could not determine IP address"
            exit 1
          fi
          
          echo "ip=$IP" >> $GITHUB_OUTPUT
      
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          cp ./ssh-key-ec2.pem ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ steps.get-ip.outputs.ip }} >> ~/.ssh/known_hosts 2>/dev/null || true
          echo "SSH setup complete"
      
      - name: Build Docker Images on GitHub
        if: steps.defaults.outputs.rebuild_docker == 'true' && steps.defaults.outputs.build_location == 'github'
        run: |
          mkdir -p /tmp
          
          # Build microservices
          for SERVICE in api-gateway micro-auth micro-estudiantes micro-maestros frontend-web; do
            if [ -f "./$SERVICE/Dockerfile" ]; then
              echo "Building $SERVICE..."
              if [ "$SERVICE" = "frontend-web" ]; then
                docker build --no-cache -t $SERVICE:latest -f ./$SERVICE/Dockerfile ./$SERVICE
              else
                docker build --no-cache -t $SERVICE:latest -f ./$SERVICE/Dockerfile .
              fi
              docker save $SERVICE:latest -o /tmp/$SERVICE.tar
            fi
          done
          
          echo "Docker images built successfully"
          ls -lh /tmp/*.tar 2>/dev/null || echo "Warning: No tar files found"
      
      - name: Transfer files to EC2
        run: |
          IP=${{ steps.get-ip.outputs.ip }}
          INSTANCE=${{ github.event.inputs.instance }}
          
          # Aggressively clean space on EC2
          echo "Cleaning EC2 instance..."
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o ConnectTimeout=30 ubuntu@$IP << 'CLEANUP'
          set -e
          echo "=== Cleaning old docker resources ==="
          docker system prune -af --volumes 2>/dev/null || true
          
          echo "=== Cleaning old .tar files ==="
          rm -f /tmp/*.tar /tmp/*.tar.gz 2>/dev/null || true
          rm -f ~/docker-images/*.tar 2>/dev/null || true
          
          echo "=== Disk usage before cleanup ==="
          df -h / | tail -1
          
          echo "=== Creating app directory ==="
          mkdir -p ~/docker-images ~/app
          
          echo "=== Disk usage after cleanup ==="
          df -h / | tail -1
          CLEANUP
          
          # Transfer Docker images to EC2 home directory
          echo "Transferring Docker images..."
          for FILE in /tmp/*.tar; do
            if [ -f "$FILE" ]; then
              echo "  Transferring $(basename $FILE)..."
              scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o ConnectTimeout=30 -C "$FILE" ubuntu@$IP:~/docker-images/ || true
            fi
          done
          
          # Transfer appropriate docker-compose.yml based on instance
          if [ "$INSTANCE" = "EC2_CORE" ]; then
            COMPOSE_FILE="./docker-compose.ec2-core.yml"
          elif [ "$INSTANCE" = "EC2_API_GATEWAY" ]; then
            COMPOSE_FILE="./docker-compose.api-gateway.yml"
          elif [ "$INSTANCE" = "EC2_FRONTEND" ]; then
            COMPOSE_FILE="./docker-compose.frontend.yml"
          elif [ "$INSTANCE" = "EC2_MESSAGING" ]; then
            COMPOSE_FILE="./messaging/docker-compose.yml"
          elif [ "$INSTANCE" = "EC2_MONITORING" ]; then
            COMPOSE_FILE="./monitoring/docker-compose.yml"
          elif [ "$INSTANCE" = "EC2_DB" ]; then
            COMPOSE_FILE="./databases/docker-compose.yml"
          else
            COMPOSE_FILE="./docker-compose.yml"
          fi
          
          if [ -f "$COMPOSE_FILE" ]; then
            scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o ConnectTimeout=30 "$COMPOSE_FILE" ubuntu@$IP:~/app/docker-compose.yml
          else
            echo "‚ö†Ô∏è Warning: $COMPOSE_FILE not found, skipping docker-compose transfer"
          fi
      
      - name: Build Docker Images on EC2
        run: |
          echo "üöÄ NEW WORKFLOW FILE (deploy-fixed.yml) - EXECUTING BUILD STEP"
          IP=${{ steps.get-ip.outputs.ip }}
          INSTANCE=${{ github.event.inputs.instance }}
          GITHUB_REPO="${{ github.repository }}"
          GITHUB_REF="${{ github.ref }}"
          
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o ConnectTimeout=30 ubuntu@$IP bash -s "$INSTANCE" "$GITHUB_REPO" "$GITHUB_REF" << 'BUILDSSH'
          set -e
          INSTANCE=$1
          GITHUB_REPO=$2
          GITHUB_REF=$3
          
          echo "=== EC2 Build: Cloning repository ==="
          cd ~
          rm -rf app-build
          git clone --depth 1 https://github.com/${GITHUB_REPO}.git app-build
          cd app-build
          git checkout ${GITHUB_REF#refs/heads/}
          
          echo "=== EC2 Build: Building images for $INSTANCE ==="
          mkdir -p ~/docker-images
          
          case "$INSTANCE" in
            EC2_MESSAGING)
              echo "Building infrastructure images for messaging..."
              if [ -f "./messaging/zookeeper/Dockerfile" ]; then
                echo "Building zookeeper..."
                docker build --no-cache -t proyecto-zookeeper:1.0 -f ./messaging/zookeeper/Dockerfile ./messaging
              fi
              if [ -f "./messaging/kafka/Dockerfile" ]; then
                echo "Building kafka..."
                docker build --no-cache -t proyecto-kafka:1.0 -f ./messaging/kafka/Dockerfile ./messaging
              fi
              if [ -f "./messaging/rabbitmq/Dockerfile" ]; then
                echo "Building rabbitmq..."
                docker build --no-cache -t proyecto-rabbitmq:1.0 -f ./messaging/rabbitmq/Dockerfile ./messaging
              fi
              ;;
            EC2_MONITORING)
              echo "Building infrastructure images for monitoring..."
              if [ -f "./monitoring/prometheus/Dockerfile" ]; then
                echo "Building prometheus..."
                docker build --no-cache -t proyecto-prometheus:1.0 -f ./monitoring/prometheus/Dockerfile ./monitoring
              fi
              if [ -f "./monitoring/grafana/Dockerfile" ]; then
                echo "Building grafana..."
                docker build --no-cache -t proyecto-grafana:1.0 -f ./monitoring/grafana/Dockerfile ./monitoring
              fi
              ;;
            *)
              echo "Building microservices..."
              for SERVICE in api-gateway micro-auth micro-estudiantes micro-maestros frontend-web; do
                if [ -f "./$SERVICE/Dockerfile" ]; then
                  echo "Building $SERVICE..."
                  if [ "$SERVICE" = "frontend-web" ]; then
                    docker build --no-cache -t $SERVICE:latest -f ./$SERVICE/Dockerfile ./$SERVICE
                  else
                    docker build --no-cache -t $SERVICE:latest -f ./$SERVICE/Dockerfile .
                  fi
                fi
              done
              ;;
          esac
          
          echo "=== EC2 Build: Images built successfully ==="
          docker images | grep -E 'proyecto|api-gateway|micro|frontend' || echo "No custom images found"
          
          echo "=== EC2 Build: Starting services with docker-compose ==="
          cd ~/app
          docker-compose down 2>/dev/null || true
          sleep 2
          docker-compose up -d
          
          echo "=== Waiting for services to be ready (30 seconds) ==="
          sleep 30
          
          echo "=== Service Status ==="
          docker-compose ps
          
          echo ""
          echo "=== Recent logs ==="
          docker-compose logs --tail=50 2>&1 || true
          BUILDSSH
      
      - name: Verify deployment
        if: always()
        continue-on-error: true
        run: |
          IP=${{ steps.get-ip.outputs.ip }}
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o ConnectTimeout=30 ubuntu@$IP bash << 'VERIFYSSH'
          
          echo "=== Verifying services status ==="
          cd ~/app
          docker-compose ps || true
          echo ""
          echo "=== Service logs (last 30 lines) ==="
          docker-compose logs --tail=30 2>&1 || echo "No logs available"
          
          echo ""
          echo "=== Deployment complete ==="
          echo "‚úÖ Workflow completed successfully"
          VERIFYSSH
