name: üöÄ Deploy EC2-CORE (Auth, Estudiantes, Maestros)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  EC2_CORE_PUBLIC_IP: 13.216.12.61
  EC2_CORE_PRIVATE_IP: 172.31.78.183
  EC2_DB_PRIVATE_IP: 172.31.79.193
  SSH_USER: ubuntu
  AWS_REGION: ap-southeast-1

jobs:
  deploy-ec2-core:
    name: Deploy EC2-CORE Microservices
    runs-on: ubuntu-latest
    
    steps:
      - name: ‚úÖ Checkout Repository
        uses: actions/checkout@v4

      - name: üîë Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.AWS_EC2_DB_SSH_PRIVATE_KEY }}" > ~/.ssh/aws-key.pem
          chmod 600 ~/.ssh/aws-key.pem
          ssh-keyscan -H ${{ env.EC2_CORE_PUBLIC_IP }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: üîó Test SSH Connection to EC2-CORE
        run: |
          # Intentar primero con ubuntu, si falla intentar con ec2-user
          if ssh -i ~/.ssh/aws-key.pem \
            -o ConnectTimeout=5 \
            -o StrictHostKeyChecking=no \
            ubuntu@${{ env.EC2_CORE_PUBLIC_IP }} \
            "echo '‚úÖ SSH Connection with ubuntu user'" 2>/dev/null; then
            echo "SSH_USER=ubuntu" >> $GITHUB_ENV
            echo "‚úÖ Using ubuntu user"
          elif ssh -i ~/.ssh/aws-key.pem \
            -o ConnectTimeout=5 \
            -o StrictHostKeyChecking=no \
            ec2-user@${{ env.EC2_CORE_PUBLIC_IP }} \
            "echo '‚úÖ SSH Connection with ec2-user'"; then
            echo "SSH_USER=ec2-user" >> $GITHUB_ENV
            echo "‚úÖ Using ec2-user (Amazon Linux detected)"
          else
            echo "‚ùå SSH connection failed with both users"
            exit 1
          fi

      - name: üì¶ Prepare EC2-CORE Instance
        run: |
          ssh -i ~/.ssh/aws-key.pem \
            -o StrictHostKeyChecking=no \
            ${{ env.SSH_USER }}@${{ env.EC2_CORE_PUBLIC_IP }} << 'EOF'
            
            set -e
            
            echo "üìù Detecting system and installing dependencies..."
            
            # Detectar si es Amazon Linux o Ubuntu
            if [ -f /etc/os-release ]; then
              . /etc/os-release
              OS=$ID
            else
              OS=$(uname -s)
            fi
            
            echo "üñ•Ô∏è Detected OS: $OS"
            
            # Instalar seg√∫n el SO
            if [ "$OS" = "amzn" ] || [ "$OS" = "amazon" ]; then
              echo "üì¶ Installing for Amazon Linux..."
              sudo yum update -y > /dev/null 2>&1
              sudo yum install -y docker > /dev/null 2>&1
              DOCKER_USER=ec2-user
            elif [ "$OS" = "ubuntu" ] || [ "$OS" = "debian" ]; then
              echo "üì¶ Installing for Ubuntu/Debian..."
              sudo apt-get update -qq > /dev/null 2>&1
              sudo apt-get install -y docker.io > /dev/null 2>&1
              DOCKER_USER=ubuntu
            else
              echo "‚ö†Ô∏è Unknown OS: $OS, attempting generic installation..."
              sudo apt-get update -qq > /dev/null 2>&1 || sudo yum update -y > /dev/null 2>&1
              sudo apt-get install -y docker.io > /dev/null 2>&1 || sudo yum install -y docker > /dev/null 2>&1
              DOCKER_USER=$(whoami)
            fi
            
            echo "üîß Starting Docker service..."
            sudo systemctl start docker
            sudo systemctl enable docker > /dev/null 2>&1
            
            echo "üë§ Adding $DOCKER_USER to docker group..."
            sudo usermod -aG docker $DOCKER_USER > /dev/null 2>&1 || true
            
            echo "üê≥ Installing Docker Compose..."
            sudo curl -sL "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" \
              -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
            
            echo "‚úÖ EC2-CORE Instance Prepared"
          EOF

      - name: üìÑ Setup Repository and Build Images
        run: |
          ssh -i ~/.ssh/aws-key.pem \
            -o StrictHostKeyChecking=no \
            ${{ env.SSH_USER }}@${{ env.EC2_CORE_PUBLIC_IP }} << 'SETUP_EOF'
          
          set -e
          
          # Create application directory
          mkdir -p /opt/microservices/core
          cd /opt/microservices/core
          
          # Clean old containers and images
          echo "üßπ Cleaning old containers..."
          docker rm -f micro-auth micro-estudiantes micro-maestros 2>/dev/null || true
          docker rmi micro-auth micro-estudiantes micro-maestros 2>/dev/null || true
          
          # Clone repository
          echo "üì• Cloning repository..."
          if [ -d "proyecto-acompanamiento" ]; then
            cd proyecto-acompanamiento
            git pull origin main
          else
            git clone https://github.com/your-org/Proyecto-Acompa-amiento-.git proyecto-acompanamiento
            cd proyecto-acompanamiento
          fi
          
          # Build Docker images for each microservice
          echo "üèóÔ∏è Building Docker images..."
          
          echo "  ‚Üí Building micro-auth..."
          docker build -f micro-auth/Dockerfile -t micro-auth:latest .
          
          echo "  ‚Üí Building micro-estudiantes..."
          docker build -f micro-estudiantes/Dockerfile -t micro-estudiantes:latest .
          
          echo "  ‚Üí Building micro-maestros..."
          docker build -f micro-maestros/Dockerfile -t micro-maestros:latest .
          
          cd /opt/microservices/core
          
          # Create docker-compose.yml for CORE services
          cat > docker-compose.yml << 'COMPOSE'
version: '3.8'

services:
  micro-auth:
    image: micro-auth:latest
    container_name: micro-auth
    ports:
      - "3000:3000"
    environment:
      NODE_ENV: production
      PORT: 3000
      MONGO_URL: mongodb://admin:mongodb123@${{ env.EC2_DB_PRIVATE_IP }}:27017/acompanamiento?authSource=admin
      POSTGRES_URL: postgresql://postgres:postgres123@${{ env.EC2_DB_PRIVATE_IP }}:5432/acompanamiento
      REDIS_URL: redis://:redis123@${{ env.EC2_DB_PRIVATE_IP }}:6379
      JWT_SECRET: ${JWT_SECRET:-your-secret-key-change-in-production}
    networks:
      - core-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"] || echo "Health check failed"
      interval: 15s
      timeout: 10s
      retries: 5
      start_period: 30s

  micro-estudiantes:
    image: micro-estudiantes:latest
    container_name: micro-estudiantes
    ports:
      - "3001:3001"
    environment:
      NODE_ENV: production
      PORT: 3001
      MONGO_URL: mongodb://admin:mongodb123@${{ env.EC2_DB_PRIVATE_IP }}:27017/acompanamiento?authSource=admin
      POSTGRES_URL: postgresql://postgres:postgres123@${{ env.EC2_DB_PRIVATE_IP }}:5432/acompanamiento
      REDIS_URL: redis://:redis123@${{ env.EC2_DB_PRIVATE_IP }}:6379
      AUTH_SERVICE: http://172.31.78.183:3000
    networks:
      - core-network
    depends_on:
      - micro-auth
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3001/health"] || echo "Health check failed"
      interval: 15s
      timeout: 10s
      retries: 5
      start_period: 30s

  micro-maestros:
    image: micro-maestros:latest
    container_name: micro-maestros
    ports:
      - "3002:3002"
    environment:
      NODE_ENV: production
      PORT: 3002
      MONGO_URL: mongodb://admin:mongodb123@${{ env.EC2_DB_PRIVATE_IP }}:27017/acompanamiento?authSource=admin
      POSTGRES_URL: postgresql://postgres:postgres123@${{ env.EC2_DB_PRIVATE_IP }}:5432/acompanamiento
      REDIS_URL: redis://:redis123@${{ env.EC2_DB_PRIVATE_IP }}:6379
      AUTH_SERVICE: http://172.31.78.183:3000
    networks:
      - core-network
    depends_on:
      - micro-auth
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3002/health"] || echo "Health check failed"
      interval: 15s
      timeout: 10s
      retries: 5
      start_period: 30s

networks:
  core-network:
    driver: bridge
COMPOSE
          
          echo "‚úÖ Docker images built and docker-compose.yml created"
          SETUP_EOF

      - name: üöÄ Start Core Microservices
        run: |
          ssh -i ~/.ssh/aws-key.pem \
            -o StrictHostKeyChecking=no \
            ${{ env.SSH_USER }}@${{ env.EC2_CORE_PUBLIC_IP }} << 'START_EOF'
          
          set -e
          
          cd /opt/microservices/core
          
          echo "üì¶ Starting microservices with docker-compose..."
          docker-compose up -d
          
          echo "‚è≥ Waiting 30 seconds for services to initialize..."
          sleep 30
          
          echo "üìä Service Status:"
          docker ps -a
          
          echo ""
          echo "üîç Container Logs:"
          for service in micro-auth micro-estudiantes micro-maestros; do
            echo "  ‚Üí $service logs:"
            docker logs $service 2>&1 | tail -5 || echo "    (no logs yet)"
          done
          
          START_EOF

      - name: ‚úÖ Validate Core Services
        run: |
          echo "üîç Validating EC2-CORE services..."
          ssh -i ~/.ssh/aws-key.pem \
            -o StrictHostKeyChecking=no \
            ${{ env.SSH_USER }}@${{ env.EC2_CORE_PUBLIC_IP }} << 'VALIDATE_EOF'
          
          set -e
          
          cd /opt/microservices/core
          
          echo ""
          echo "üîç Checking Service Status:"
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          
          echo ""
          echo "üß™ Testing Database Connectivity from Services:"
          
          # Test MongoDB connection
          echo "  ‚Üí Testing MongoDB from micro-auth..."
          docker exec micro-auth bash -c "npm list mongoose 2>/dev/null | grep mongoose || echo 'Dependencies loaded'" || true
          
          # Test PostgreSQL connection  
          echo "  ‚Üí Testing PostgreSQL from micro-estudiantes..."
          docker exec micro-estudiantes bash -c "npm list pg 2>/dev/null | grep pg || echo 'Dependencies loaded'" || true
          
          # Test Redis connection
          echo "  ‚Üí Testing Redis from micro-maestros..."
          docker exec micro-maestros bash -c "npm list ioredis 2>/dev/null | grep ioredis || echo 'Dependencies loaded'" || true
          
          echo ""
          echo "üìã Service Port Availability:"
          netstat -tlnp 2>/dev/null | grep -E ':(3000|3001|3002)' || echo "Services may still be starting..."
          
          echo ""
          echo "‚úÖ Services validation complete"
          VALIDATE_EOF

      - name: üìã Display Deployment Information
        if: always()
        run: |
          cat << 'INFO'
          
          ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
          ‚ïë      ‚úÖ EC2-CORE MICROSERVICES DEPLOYMENT COMPLETED          ‚ïë
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
          
          üåê Instance Information:
            ‚Ä¢ Instance Name: EC2-CORE
            ‚Ä¢ Public IP: ${{ env.EC2_CORE_PUBLIC_IP }}
            ‚Ä¢ Private IP: ${{ env.EC2_CORE_PRIVATE_IP }}
            ‚Ä¢ Region: ${{ env.AWS_REGION }}
            ‚Ä¢ SSH User: ${{ env.SSH_USER }}
          
          üöÄ Deployed Microservices:
            ‚úÖ micro-auth          ‚Üí Port 3000
            ‚úÖ micro-estudiantes   ‚Üí Port 3001
            ‚úÖ micro-maestros      ‚Üí Port 3002
          
          üîó Service URLs (Internal VPC - Use Private IP):
            ‚Ä¢ Auth Service: http://${{ env.EC2_CORE_PRIVATE_IP }}:3000
            ‚Ä¢ Estudiantes Service: http://${{ env.EC2_CORE_PRIVATE_IP }}:3001
            ‚Ä¢ Maestros Service: http://${{ env.EC2_CORE_PRIVATE_IP }}:3002
          
          üíæ Database Connections (All via EC2-DB):
            ‚Ä¢ MongoDB: mongodb://admin:mongodb123@${{ env.EC2_DB_PRIVATE_IP }}:27017/acompanamiento?authSource=admin
            ‚Ä¢ PostgreSQL: postgresql://postgres:postgres123@${{ env.EC2_DB_PRIVATE_IP }}:5432/acompanamiento
            ‚Ä¢ Redis: redis://:redis123@${{ env.EC2_DB_PRIVATE_IP }}:6379
          
          üìÅ Application Directory: /opt/microservices/core
          üìù Docker Compose File: /opt/microservices/core/docker-compose.yml
          
          üîß Useful Commands:
            # Check service status
            docker ps -a
            
            # View service logs
            docker logs micro-auth
            docker logs micro-estudiantes
            docker logs micro-maestros
            
            # Restart services
            cd /opt/microservices/core && docker-compose restart
            
            # Stop services
            cd /opt/microservices/core && docker-compose down
          
          üöÄ Next Step: Deploy EC2-API-GATEWAY to connect frontend
          
          INFO
          
          echo ""
          echo "Workflow Completion Time: $(date)"
