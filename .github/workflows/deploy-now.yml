name: Deploy on Demand

on:
  push:
    paths:
      - 'DEPLOY_NOW'
      - '.github/workflows/deploy-now.yml'
  workflow_dispatch:
    inputs:
      instance:
        description: 'Instance to deploy'
        required: true
        default: 'EC2_CORE'
        type: choice
        options:
          - EC2_BASTION
          - EC2_CORE
          - EC2_DB
          - EC2_API_GATEWAY
          - EC2_FRONTEND
          - EC2_MESSAGING
          - EC2_MONITORING
      rebuild_docker:
        description: 'Rebuild Docker images'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      build_location:
        description: 'Where to build images'
        required: false
        default: 'ec2'
        type: choice
        options:
          - 'ec2'
          - 'github'
      environment:
        description: 'Environment'
        required: false
        default: 'prod'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  AWS_REGION: us-east-1
  DOCKER_BUILDKIT: 1

jobs:
  deploy-ec2:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    permissions:
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set defaults for push trigger
        id: defaults
        run: |
          INSTANCE="${{ github.event.inputs.instance || 'EC2_CORE' }}"
          REBUILD="${{ github.event.inputs.rebuild_docker || 'true' }}"
          BUILD_LOCATION="${{ github.event.inputs.build_location || 'ec2' }}"
          ENVIRONMENT="${{ github.event.inputs.environment || 'prod' }}"
          echo "instance=${INSTANCE}" >> $GITHUB_OUTPUT
          echo "rebuild_docker=${REBUILD}" >> $GITHUB_OUTPUT
          echo "build_location=${BUILD_LOCATION}" >> $GITHUB_OUTPUT
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN || '' }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Get EC2 IP (Dynamic Discovery)
        id: get-ip
        run: |
          INSTANCE="${{ steps.defaults.outputs.instance }}"
          
          case "$INSTANCE" in
            EC2_CORE)
              TAG_NAME="EC2-CORE"
              ;;
            *)
              TAG_NAME="$INSTANCE"
              ;;
          esac
          
          # Query AWS for the instance IP using exact tag match
          IP=$(aws ec2 describe-instances \
            --region ${AWS_REGION} \
            --filters "Name=tag:Name,Values=${TAG_NAME}" "Name=instance-state-name,Values=running" \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)
          
          if [ -z "$IP" ] || [ "$IP" = "None" ]; then
            echo "ERROR: Could not find running instance with tag ${TAG_NAME}"
            aws ec2 describe-instances --region ${AWS_REGION} --query 'Reservations[].Instances[].[Tags[?Key==`Name`].Value|[0],InstanceType,State.Name]' --output table
            exit 1
          fi
          
          echo "ip=${IP}" >> $GITHUB_OUTPUT
          echo "Found IP: ${IP}"
      
      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" | base64 -d > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ steps.get-ip.outputs.ip }} >> ~/.ssh/known_hosts 2>/dev/null || true
      
      - name: Deploy Code to EC2
        run: |
          SSH_CMD="ssh -i ~/.ssh/id_rsa -o ConnectTimeout=10 -o StrictHostKeyChecking=no ubuntu@${{ steps.get-ip.outputs.ip }}"
          
          echo "Syncing code to EC2..."
          rsync -avz -e "ssh -i ~/.ssh/id_rsa -o ConnectTimeout=10 -o StrictHostKeyChecking=no" \
            --exclude='.git' \
            --exclude='node_modules' \
            --exclude='.env' \
            --exclude='terraform' \
            ./ ubuntu@${{ steps.get-ip.outputs.ip }}:/home/ubuntu/project/
          
          echo "Stopping services..."
          $SSH_CMD "cd /home/ubuntu/project && docker-compose down || true" || true
      
      - name: Rebuild Docker Images
        if: ${{ steps.defaults.outputs.rebuild_docker == 'true' }}
        run: |
          SSH_CMD="ssh -i ~/.ssh/id_rsa -o ConnectTimeout=10 -o StrictHostKeyChecking=no ubuntu@${{ steps.get-ip.outputs.ip }}"
          
          echo "Rebuilding Docker images on EC2..."
          $SSH_CMD << 'REMOTE_SCRIPT'
          cd /home/ubuntu/project
          docker-compose build --no-cache api-gateway core auth db frontend || true
          docker image prune -f || true
          REMOTE_SCRIPT
      
      - name: Start Services
        run: |
          SSH_CMD="ssh -i ~/.ssh/id_rsa -o ConnectTimeout=10 -o StrictHostKeyChecking=no ubuntu@${{ steps.get-ip.outputs.ip }}"
          
          echo "Starting services..."
          $SSH_CMD << 'REMOTE_SCRIPT'
          cd /home/ubuntu/project
          docker-compose up -d api-gateway core auth db frontend
          sleep 5
          docker-compose ps
          REMOTE_SCRIPT
      
      - name: Verify Deployment
        run: |
          IP="${{ steps.get-ip.outputs.ip }}"
          
          echo "Waiting for services to stabilize..."
          sleep 10
          
          # Try to reach the application
          for i in {1..10}; do
            if curl -s -f http://${IP}:3000/health &>/dev/null || curl -s -f http://${IP}:8000/api/health &>/dev/null; then
              echo "[SUCCESS] Application is responding!"
              echo "Application URL: http://${IP}:3000"
              exit 0
            fi
            echo "Attempt $i/10 - Service not yet ready, waiting..."
            sleep 5
          done
          
          echo "[WARNING] Could not verify health check, but deployment may still be successful"
          echo "Check manually at: http://${IP}:3000"
