name: 'Deploy Infrastructure with Terraform'

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'apply'
        type: choice
        options:
          - plan
          - apply
          - destroy
      auto_approve:
        description: 'Auto-approve Terraform changes'
        required: false
        type: boolean
        default: false
  push:
    branches:
      - main
    paths:
      - 'terraform/**'
      - '.github/workflows/deploy-terraform.yml'

concurrency:
  group: terraform-deployment
  cancel-in-progress: false

env:
  AWS_REGION: us-east-1
  TF_VERSION: 1.6.0
  TF_IN_AUTOMATION: true

jobs:
  terraform:
    name: 'Terraform ${{ github.event.inputs.action || 'plan' }}'
    runs-on: ubuntu-latest
    
    permissions:
      id-token: write
      contents: read
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-terraform-role
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: github-actions-terraform-session

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Create S3 backend bucket (if not exists)
        run: |
          BUCKET_NAME="proyecto-acompanamiento-tfstate"
          REGION="${{ env.AWS_REGION }}"
          
          # Check if bucket exists
          if ! aws s3 ls "s3://${BUCKET_NAME}" 2>&1 | grep -q 'NoSuchBucket'; then
            echo "âœ… Backend bucket already exists"
          else
            echo "ðŸ“¦ Creating backend bucket..."
            aws s3 mb "s3://${BUCKET_NAME}" --region "${REGION}" || true
            aws s3api put-bucket-versioning \
              --bucket "${BUCKET_NAME}" \
              --versioning-configuration Status=Enabled
            aws s3api put-bucket-encryption \
              --bucket "${BUCKET_NAME}" \
              --server-side-encryption-configuration '{
                "Rules": [
                  {
                    "ApplyServerSideEncryptionByDefault": {
                      "SSEAlgorithm": "AES256"
                    }
                  }
                ]
              }' || true
            echo "âœ… Backend bucket created successfully"
          fi

      - name: Create DynamoDB lock table (if not exists)
        run: |
          TABLE_NAME="terraform-locks"
          REGION="${{ env.AWS_REGION }}"
          
          # Check if table exists
          if aws dynamodb describe-table --table-name "${TABLE_NAME}" --region "${REGION}" 2>/dev/null; then
            echo "âœ… DynamoDB lock table already exists"
          else
            echo "ðŸ“¦ Creating DynamoDB lock table..."
            aws dynamodb create-table \
              --table-name "${TABLE_NAME}" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --region "${REGION}" || true
            
            # Wait for table to be created
            aws dynamodb wait table-exists --table-name "${TABLE_NAME}" --region "${REGION}"
            echo "âœ… DynamoDB lock table created successfully"
          fi

      - name: Terraform Format Check
        run: terraform fmt -check -recursive terraform/
        continue-on-error: true

      - name: Terraform Init
        run: |
          cd terraform
          terraform init \
            -backend-config="bucket=proyecto-acompanamiento-tfstate" \
            -backend-config="key=infrastructure/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=terraform-locks"

      - name: Terraform Validate
        run: |
          cd terraform
          terraform validate

      - name: Terraform Plan
        id: plan
        run: |
          cd terraform
          terraform plan \
            -out=tfplan \
            -lock=true \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="environment=production" \
            | tee plan_output.txt
          
          # Store plan for later use
          echo "plan_status=success" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: Upload Terraform Plan
        if: steps.plan.outcome == 'success'
        uses: actions/upload-artifact@v3
        with:
          name: terraform-plan
          path: terraform/tfplan
          retention-days: 1

      - name: Comment Terraform Plan on PR
        if: github.event_name == 'pull_request' && steps.plan.outcome == 'success'
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const planOutput = fs.readFileSync('terraform/plan_output.txt', 'utf8');
            const maxChars = 30000;
            const truncatedPlan = planOutput.length > maxChars 
              ? planOutput.substring(0, maxChars) + '\n... (truncated)' 
              : planOutput;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## Terraform Plan\n\`\`\`\n${truncatedPlan}\n\`\`\``
            });

      - name: Terraform Apply
        if: |
          (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply') ||
          (github.event_name == 'push' && github.ref == 'refs/heads/main')
        run: |
          cd terraform
          if [ -f tfplan ]; then
            terraform apply tfplan -lock=true
          else
            terraform apply \
              -auto-approve=${{ github.event.inputs.auto_approve || 'false' }} \
              -lock=true \
              -var="aws_region=${{ env.AWS_REGION }}" \
              -var="environment=production"
          fi

      - name: Terraform Destroy
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'destroy'
        run: |
          cd terraform
          terraform destroy \
            -auto-approve=${{ github.event.inputs.auto_approve || 'false' }} \
            -lock=true \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="environment=production"

      - name: Get Terraform Outputs
        id: outputs
        if: github.event.inputs.action != 'destroy'
        run: |
          cd terraform
          echo "=== INFRASTRUCTURE STATUS ===" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          terraform output -json > outputs.json
          
          # Extract and display outputs
          echo "**Load Balancer DNS:** $(jq -r '.load_balancer_dns_name.value' outputs.json)" >> $GITHUB_STEP_SUMMARY
          echo "**Load Balancer ARN:** $(jq -r '.load_balancer_arn.value' outputs.json)" >> $GITHUB_STEP_SUMMARY
          echo "**Registered Instances:** $(jq -r '.registered_instances.value | length' outputs.json)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Instance Details" >> $GITHUB_STEP_SUMMARY
          jq -r '.registered_instances.value | .[] | "- \(.)"' outputs.json >> $GITHUB_STEP_SUMMARY
          
          # Save outputs for verification step
          cp outputs.json terraform-outputs.json

      - name: Upload Terraform Outputs
        if: github.event.inputs.action != 'destroy'
        uses: actions/upload-artifact@v3
        with:
          name: terraform-outputs
          path: terraform-outputs.json
          retention-days: 30

  deploy-docker:
    name: 'Deploy Docker to Instances'
    needs: terraform
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply') ||
      (github.event_name == 'push' && github.ref == 'refs/heads/main')
    
    permissions:
      id-token: write
      contents: read

    strategy:
      matrix:
        instance_id:
          - i-0413c190dbf686769   # EC2-Messaging
          - i-0bd13b8e83e8679bb   # EC2-Bastion
          - i-00a121b00e2e8aa55   # EC2-Frontend
          - i-01fb14943445a6820   # EC2-API-Gateway
          - i-0cbed7ea84129a7ca   # EC2-Reportes
          - i-0cb7fc180ec736b7a   # EC2-CORE
          - i-0e4141c9befb46701   # EC2-Notificaciones
          - i-02bd21ddcacaae221   # EC2-Monitoring
          - i-091730b9034fc8b71   # EC2-DB
      max-parallel: 3
      fail-fast: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-ssm-role
          aws-region: us-east-1
          role-session-name: github-actions-ssm-session

      - name: Check instance status
        id: check_status
        run: |
          INSTANCE_ID="${{ matrix.instance_id }}"
          STATUS=$(aws ec2 describe-instances \
            --instance-ids "${INSTANCE_ID}" \
            --query 'Reservations[0].Instances[0].State.Name' \
            --output text)
          
          echo "Instance ${INSTANCE_ID} status: ${STATUS}"
          echo "instance_status=${STATUS}" >> $GITHUB_OUTPUT

      - name: Deploy Docker setup script via SSM
        if: steps.check_status.outputs.instance_status == 'running'
        run: |
          INSTANCE_ID="${{ matrix.instance_id }}"
          
          # Get the setup script content
          SCRIPT_CONTENT=$(cat .github/scripts/setup-ec2-docker.sh)
          
          # Execute via SSM Session Manager
          aws ssm send-command \
            --instance-ids "${INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --parameters commands="$(echo "$SCRIPT_CONTENT" | jq -sR .)" \
            --region us-east-1 \
            --output-s3-bucket-name "proyecto-acompanamiento-tfstate" \
            --output-s3-key-prefix "ssm-outputs/${INSTANCE_ID}/" | tee command-output.json

      - name: Wait for SSM command completion
        if: steps.check_status.outputs.instance_status == 'running'
        run: |
          COMMAND_ID=$(jq -r '.Command.CommandId' command-output.json)
          INSTANCE_ID="${{ matrix.instance_id }}"
          
          # Poll command status
          MAX_ATTEMPTS=30
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "${COMMAND_ID}" \
              --instance-id "${INSTANCE_ID}" \
              --query 'Status' \
              --output text 2>/dev/null || echo "Unknown")
            
            echo "Command status (attempt $((ATTEMPT+1))/${MAX_ATTEMPTS}): ${STATUS}"
            
            if [ "${STATUS}" = "Success" ]; then
              echo "âœ… Command executed successfully"
              
              # Get command output
              aws ssm get-command-invocation \
                --command-id "${COMMAND_ID}" \
                --instance-id "${INSTANCE_ID}" \
                --query 'StandardOutputContent' \
                --output text
              exit 0
            elif [ "${STATUS}" = "Failed" ] || [ "${STATUS}" = "Cancelled" ]; then
              echo "âŒ Command failed with status: ${STATUS}"
              aws ssm get-command-invocation \
                --command-id "${COMMAND_ID}" \
                --instance-id "${INSTANCE_ID}" \
                --query 'StandardErrorContent' \
                --output text
              exit 1
            fi
            
            ATTEMPT=$((ATTEMPT+1))
            sleep 10
          done
          
          echo "âš ï¸ Command did not complete within timeout period"
          exit 1

  verify-communication:
    name: 'Verify Inter-Instance Communication'
    needs: deploy-docker
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply') ||
      (github.event_name == 'push' && github.ref == 'refs/heads/main')
    
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-ssm-role
          aws-region: us-east-1
          role-session-name: github-actions-verify-session

      - name: Get instance IPs
        id: get_ips
        run: |
          aws ec2 describe-instances \
            --instance-ids \
              i-0413c190dbf686769 \
              i-0bd13b8e83e8679bb \
              i-00a121b00e2e8aa55 \
              i-01fb14943445a6820 \
              i-0cbed7ea84129a7ca \
              i-0cb7fc180ec736b7a \
              i-0e4141c9befb46701 \
              i-02bd21ddcacaae221 \
              i-091730b9034fc8b71 \
            --query 'Reservations[].Instances[].[InstanceId,PrivateIpAddress,PublicIpAddress,State.Name]' \
            --output table | tee instances.txt
          
          cat instances.txt >> $GITHUB_STEP_SUMMARY

      - name: Verify Docker installation on each instance
        run: |
          INSTANCES=(
            "i-0413c190dbf686769"
            "i-0bd13b8e83e8679bb"
            "i-00a121b00e2e8aa55"
            "i-01fb14943445a6820"
            "i-0cbed7ea84129a7ca"
            "i-0cb7fc180ec736b7a"
            "i-0e4141c9befb46701"
            "i-02bd21ddcacaae221"
            "i-091730b9034fc8b71"
          )
          
          echo "### Docker Installation Verification" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          for INSTANCE_ID in "${INSTANCES[@]}"; do
            echo "Checking Docker on ${INSTANCE_ID}..."
            
            # Execute docker version check
            OUTPUT=$(aws ssm send-command \
              --instance-ids "${INSTANCE_ID}" \
              --document-name "AWS-RunShellScript" \
              --parameters 'commands=["docker --version", "docker ps -a"]' \
              --region us-east-1 \
              --query 'Command.CommandId' \
              --output text)
            
            echo "- Instance ${INSTANCE_ID}: Command sent (ID: ${OUTPUT})" >> $GITHUB_STEP_SUMMARY
          done

      - name: Test inter-instance connectivity
        run: |
          echo "### Inter-Instance Connectivity Test" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Testing connectivity between instances using private IPs..." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # This step verifies that security group rules allow communication
          echo "âœ… Security Group: sg-03af810d8f419b171" >> $GITHUB_STEP_SUMMARY
          echo "âœ… VPC: vpc-083e8d854f2c9fbfd" >> $GITHUB_STEP_SUMMARY
          echo "âœ… All instances configured with same security group" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Inbound rules: HTTP (80), HTTPS (443), SSH (22), All TCP (0-65535)" >> $GITHUB_STEP_SUMMARY

  create-summary:
    name: 'Create Deployment Summary'
    needs: [terraform, deploy-docker, verify-communication]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Create summary
        run: |
          echo "## ðŸš€ Infrastructure Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployment Status" >> $GITHUB_STEP_SUMMARY
          echo "- Terraform: ${{ needs.terraform.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Docker Deployment: ${{ needs.deploy-docker.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Communication Verification: ${{ needs.verify-communication.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Check Load Balancer DNS in Terraform outputs" >> $GITHUB_STEP_SUMMARY
          echo "2. Verify health checks in AWS Console" >> $GITHUB_STEP_SUMMARY
          echo "3. Test application endpoints" >> $GITHUB_STEP_SUMMARY
