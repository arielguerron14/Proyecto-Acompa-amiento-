name: Terraform Inventory & Deploy (Nginx Strategy)

# Deployment Strategy: Nginx standalone (v9)
# - User data deploys minimal nginx server (~30-60 seconds)
# - Replaces docker-compose strategy that took 15+ minutes
# - Provides /health (ALB health check) and / (root endpoint)
# - Can be upgraded to full microservices later with ECR images

on:
  push:
    branches: [main]
    paths:
      - 'terraform/**'
      - '.github/workflows/terraform.yml'
  workflow_dispatch:
    inputs:
      apply:
        description: 'Perform terraform apply (true/false)'
        required: false
        default: 'false'
      environment:
        description: 'Environment name (e.g., dev, staging, prod)'
        required: false
        default: 'staging'

jobs:
  inventory:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Configure AWS credentials for inventory
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
        aws-region: us-east-1

    - name: Create output dir
      run: mkdir -p artifact

    - name: Caller identity
      run: aws sts get-caller-identity --output json > artifact/caller_identity.json

    - name: Describe EC2 instances
      run: aws ec2 describe-instances --region us-east-1 --output json > artifact/ec2_instances.json || true

    - name: Describe VPCs
      run: aws ec2 describe-vpcs --region us-east-1 --output json > artifact/vpcs.json || true

    - name: List S3 buckets (optional)
      run: aws s3api list-buckets --output json > artifact/s3_buckets.json || true

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: aws-inventory
        path: artifact

  assume_role:
    runs-on: ubuntu-latest
    needs: inventory
    outputs:
      aws_access_key_id: ${{ steps.assume.outputs.aws_access_key_id }}
      aws_secret_access_key: ${{ steps.assume.outputs.aws_secret_access_key }}
      aws_session_token: ${{ steps.assume.outputs.aws_session_token }}

    steps:
    - name: Configure AWS (caller creds)
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
        aws-region: us-east-1

    - name: Install jq
      run: sudo apt-get update && sudo apt-get install -y jq

    - name: Assume role
      id: assume
      run: |
        ROLE_ARN="${{ github.event.inputs.deploy_role_arn }}"
        if [ -z "$ROLE_ARN" ]; then
          echo "No deploy_role_arn provided - will use repo secrets for deploy"
          echo "aws_access_key_id=" >> $GITHUB_OUTPUT
          echo "aws_secret_access_key=" >> $GITHUB_OUTPUT
          echo "aws_session_token=" >> $GITHUB_OUTPUT
        else
          echo "Assuming role $ROLE_ARN"
          CREDS=$(aws sts assume-role --role-arn "$ROLE_ARN" --role-session-name "gh-workflow" --duration-seconds 3600 --output json)
          AWS_ACCESS_KEY_ID=$(echo "$CREDS" | jq -r '.Credentials.AccessKeyId')
          AWS_SECRET_ACCESS_KEY=$(echo "$CREDS" | jq -r '.Credentials.SecretAccessKey')
          AWS_SESSION_TOKEN=$(echo "$CREDS" | jq -r '.Credentials.SessionToken')
          echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" >> $GITHUB_OUTPUT
          echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" >> $GITHUB_OUTPUT
          echo "aws_session_token=$AWS_SESSION_TOKEN" >> $GITHUB_OUTPUT
        fi

  deploy:
    runs-on: ubuntu-latest
    needs: assume_role
    environment: ${{ github.event.inputs.environment || 'staging' }}

    steps:
    - uses: actions/checkout@v4

    - name: Set AWS creds (assumed or repo secrets)
      run: |
        echo "AWS_ACCESS_KEY_ID=${{ needs.assume_role.outputs.aws_access_key_id || secrets.AWS_ACCESS_KEY_ID }}" >> $GITHUB_ENV
        echo "AWS_SECRET_ACCESS_KEY=${{ needs.assume_role.outputs.aws_secret_access_key || secrets.AWS_SECRET_ACCESS_KEY }}" >> $GITHUB_ENV
        echo "AWS_SESSION_TOKEN=${{ needs.assume_role.outputs.aws_session_token || secrets.AWS_SESSION_TOKEN }}" >> $GITHUB_ENV
        echo "AWS_REGION=${{ github.event.inputs.deploy_region || 'us-east-1' }}" >> $GITHUB_ENV

    - name: Show environment info
      run: |
        echo "Deployment environment: ${{ github.event.inputs.environment }}"
        echo "If this environment has protection rules, this job will pause until reviewers approve."

    - uses: hashicorp/setup-terraform@v3

    - name: Configure AWS (for terraform)
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
        aws-session-token: ${{ env.AWS_SESSION_TOKEN }}
        aws-region: ${{ env.AWS_REGION }}

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

    - name: Clean up conflicting resources (if exists)
      if: ${{ github.event.inputs.apply == 'true' }}
      run: |
        # Delete ALB if it exists
        ALB_ARN=$(aws elbv2 describe-load-balancers --query "LoadBalancers[?LoadBalancerName=='lab-alb'].LoadBalancerArn" --output text || true)
        if [ ! -z "$ALB_ARN" ] && [ "$ALB_ARN" != "None" ]; then
          echo "Found existing ALB: $ALB_ARN"
          aws elbv2 delete-load-balancer --load-balancer-arn "$ALB_ARN" 2>/dev/null && echo "Deleted ALB" || echo "Could not delete ALB"
          sleep 10  # Wait for ALB deletion before deleting target group
        fi
        
        # Delete target group if it exists
        TG_ARN=$(aws elbv2 describe-target-groups --query "TargetGroups[?TargetGroupName=='lab-alb-web-tg'].TargetGroupArn" --output text || true)
        if [ ! -z "$TG_ARN" ] && [ "$TG_ARN" != "None" ]; then
          echo "Found existing target group: $TG_ARN"
          aws elbv2 delete-target-group --target-group-arn "$TG_ARN" 2>/dev/null && echo "Deleted target group" || echo "Could not delete target group"
        fi
        
        # Terminate EC2 instances with Project tag to free up security group
        INSTANCE_IDS=$(aws ec2 describe-instances --filters "Name=tag:Project,Values=lab-8-ec2" "Name=instance-state-name,Values=running,stopped" --query 'Reservations[*].Instances[*].InstanceId' --output text || true)
        if [ ! -z "$INSTANCE_IDS" ]; then
          echo "Found instances to terminate: $INSTANCE_IDS"
          aws ec2 terminate-instances --instance-ids $INSTANCE_IDS 2>/dev/null && echo "Terminated instances" || echo "Could not terminate instances"
          sleep 20  # Wait longer for instances to fully terminate and release resources
        fi
        
        # Release ALL unassociated EIPs in the account (not associated with any instance)
        echo "Releasing unassociated EIPs..."
        EIP_ALLOCS=$(aws ec2 describe-addresses --query 'Addresses[?AssociationId==null].AllocationId' --output text || true)
        if [ ! -z "$EIP_ALLOCS" ]; then
          echo "Found unassociated EIPs to release: $EIP_ALLOCS"
          for EIP_ID in $EIP_ALLOCS; do
            echo "Releasing EIP: $EIP_ID"
            aws ec2 release-address --allocation-id $EIP_ID 2>/dev/null && echo "Released EIP $EIP_ID" || echo "Could not release EIP $EIP_ID"
          done
        else
          echo "No unassociated EIPs found"
        fi
        
        # Delete all security groups created by this project
        echo "Deleting security groups..."
        SG_NAMES=("web-sg" "bastion-sg" "api-gateway-sg" "microservices-sg" "database-sg" "messaging-sg" "monitoring-sg" "lab-sg-1" "lab-sg-2" "lab-sg-3" "lab-sg-4")
        for SG_NAME in "${SG_NAMES[@]}"; do
          SG_ID=$(aws ec2 describe-security-groups --filters Name=group-name,Values=$SG_NAME --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || true)
          if [ ! -z "$SG_ID" ] && [ "$SG_ID" != "None" ]; then
            echo "Found security group $SG_NAME: $SG_ID"
            # Revoke all ingress rules
            aws ec2 describe-security-groups --group-ids $SG_ID --query 'SecurityGroups[0].IpPermissions' --output json > /tmp/ingress_rules.json 2>/dev/null || true
            if [ -s /tmp/ingress_rules.json ] && [ "$(cat /tmp/ingress_rules.json)" != "[]" ]; then
              aws ec2 revoke-security-group-ingress --group-id $SG_ID --ip-permissions file:///tmp/ingress_rules.json 2>/dev/null || true
            fi
            # Revoke all egress rules
            aws ec2 describe-security-groups --group-ids $SG_ID --query 'SecurityGroups[0].IpPermissionsEgress' --output json > /tmp/egress_rules.json 2>/dev/null || true
            if [ -s /tmp/egress_rules.json ] && [ "$(cat /tmp/egress_rules.json)" != "[]" ]; then
              aws ec2 revoke-security-group-egress --group-id $SG_ID --ip-permissions file:///tmp/egress_rules.json 2>/dev/null || true
            fi
            # Try to delete with retries
            for attempt in 1 2 3; do
              aws ec2 delete-security-group --group-id $SG_ID 2>/dev/null && echo "Deleted $SG_NAME" && break || echo "Attempt $attempt: Could not delete $SG_NAME yet..."
              if [ $attempt -lt 3 ]; then sleep 5; fi
            done
          fi
        done

    - name: Debug - show runner paths and terraform folder
      run: |
        echo "Current directory: $(pwd)"
        echo "Repo root content:"
        ls -l
        echo "\nParent directory content:"
        ls -l ..
        echo "\nTerraform directory content:"
        ls -l terraform || echo "No terraform directory found!"

    - name: Detect VPC, Subnet (us-east-1f), keypair, and AMI
      run: |
        # Try to read inventory artifact if present
        if [ -f artifact/vpcs.json ]; then
          VPC_ID=$(jq -r '.Vpcs[] | select(.IsDefault==true) | .VpcId' artifact/vpcs.json || true)
        fi
        if [ -z "$VPC_ID" ] || [ "$VPC_ID" = "null" ]; then
          VPC_ID=$(aws ec2 describe-vpcs --filters Name=is-default,Values=true --query 'Vpcs[0].VpcId' --output text || true)
        fi
        echo "Found VPC: $VPC_ID"
        SUBNET_ID=$(aws ec2 describe-subnets --filters Name=vpc-id,Values=$VPC_ID Name=availability-zone,Values=us-east-1f --query 'Subnets[0].SubnetId' --output text || true)
        if [ -z "$SUBNET_ID" ] || [ "$SUBNET_ID" = "None" ]; then
          SUBNET_ID=$(aws ec2 describe-subnets --filters Name=vpc-id,Values=$VPC_ID --query 'Subnets[0].SubnetId' --output text || true)
        fi
        echo "Found Subnet: $SUBNET_ID"
        KEY_NAME=$(aws ec2 describe-key-pairs --query 'KeyPairs[0].KeyName' --output text || true)
        echo "Found KeyPair: $KEY_NAME"
        # Lookup latest Canonical Ubuntu 24.04 AMI in us-east-1
        AMI_ID=$(aws ec2 describe-images --owners 099720109477 --filters "Name=name,Values=ubuntu/images/hvm-ssd/ubuntu-noble-24.04-amd64-server-*" --region us-east-1 --query 'sort_by(Images, &CreationDate)[-1].ImageId' --output text || true)
        if [ -z "$AMI_ID" ] || [ "$AMI_ID" = "None" ]; then
          # Fallback: use a generic Ubuntu AMI query
          AMI_ID=$(aws ec2 describe-images --owners 099720109477 --filters "Name=name,Values=ubuntu/images/hvm-ssd/ubuntu-*-amd64-server-*" --region us-east-1 --query 'sort_by(Images, &CreationDate)[-1].ImageId' --output text || true)
        fi
        echo "Found Ubuntu AMI: $AMI_ID"
        echo "TF_VAR_existing_vpc_id=$VPC_ID" >> $GITHUB_ENV
        echo "TF_VAR_subnet_id=$SUBNET_ID" >> $GITHUB_ENV
        echo "TF_VAR_ssh_key_name=$KEY_NAME" >> $GITHUB_ENV
          echo "TF_VAR_azs=[\"us-east-1a\",\"us-east-1b\"]" >> $GITHUB_ENV
        echo "TF_VAR_instance_type=t3.small" >> $GITHUB_ENV
        echo "TF_VAR_create_instances=true" >> $GITHUB_ENV
        echo "TF_VAR_create_security_group=true" >> $GITHUB_ENV
        echo "TF_VAR_ami_id=$AMI_ID" >> $GITHUB_ENV
          # Determine available Elastic IP capacity and trim desired list accordingly
          DESIRED='["EC-Bastion","EC2-Frontend","EC2-API-Gateway","EC2-Reportes","EC2-Monitoring"]'
          TOTAL=$(aws service-quotas get-service-quota --service-code ec2 --quota-code L-0263D0A3 --query 'Quota.Value' --output text 2>/dev/null || echo 5)
          INUSE=$(aws ec2 describe-addresses --query 'length(Addresses)' --output text 2>/dev/null || echo 0)
          REMAINING=$((TOTAL - INUSE))
          if [ $REMAINING -lt 0 ]; then REMAINING=0; fi
          TRIMMED=$(echo $DESIRED | jq -c --argjson n $REMAINING '.[0:$n]')
          echo "Elastic IPs quota: $TOTAL, in use: $INUSE, remaining: $REMAINING"
          echo "TF_VAR_eip_instances=$TRIMMED" >> $GITHUB_ENV

    - name: Init
      run: cd terraform && terraform init

    - name: Plan
      run: cd terraform && terraform plan -out=tfplan

    - name: Apply
      if: ${{ github.event.inputs.apply == 'true' }}
      run: cd terraform && terraform apply -auto-approve tfplan

    - name: Deployment Summary
      if: ${{ github.event.inputs.apply == 'true' }}
      run: |
        echo "âœ… Terraform Applied Successfully"
        echo ""
        echo "Deployment Strategy: Nginx Standalone (v9)"
        echo "- User data runs nginx installation (30-60 seconds)"
        echo "- Endpoints: /health (health check) and / (root)"
        echo "- ALB will route traffic immediately"
        echo ""
        echo "Next Steps:"
        echo "1. Wait 2 minutes for instance startup"
        echo "2. Check ALB health checks in AWS Console"
        echo "3. Test endpoints once healthy"

