name: Deploy to EC2 (Dynamic IP Discovery)

on:
  workflow_dispatch:
    inputs:
      instance:
        description: 'Instance to deploy'
        required: true
        default: 'EC2_CORE'
        type: choice
        options:
          - EC2_BASTION
          - EC2_CORE
          - EC2_DB
          - EC2_API_GATEWAY
          - EC2_FRONTEND
          - EC2_MESSAGING
          - EC2_MONITORING
      rebuild_docker:
        description: 'Rebuild Docker images'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      build_location:
        description: 'Where to build images'
        required: false
        default: 'ec2'
        type: choice
        options:
          - 'ec2'
          - 'github'
      environment:
        description: 'Environment'
        required: true
        default: 'prod'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  AWS_REGION: us-east-1
  DOCKER_BUILDKIT: 1

jobs:
  deploy-ec2:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    permissions:
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set defaults for missing inputs
        id: defaults
        run: |
          REBUILD_DOCKER="${{ github.event.inputs.rebuild_docker || 'true' }}"
          BUILD_LOCATION="${{ github.event.inputs.build_location || 'ec2' }}"
          ENVIRONMENT="${{ github.event.inputs.environment || 'prod' }}"
          echo "rebuild_docker=${REBUILD_DOCKER}" >> $GITHUB_OUTPUT
          echo "build_location=${BUILD_LOCATION}" >> $GITHUB_OUTPUT
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          echo "REBUILD_DOCKER=${REBUILD_DOCKER}" >> $GITHUB_ENV
          echo "BUILD_LOCATION=${BUILD_LOCATION}" >> $GITHUB_ENV
          echo "ENVIRONMENT=${ENVIRONMENT}" >> $GITHUB_ENV
          echo "INSTANCE=${{ github.event.inputs.instance }}" >> $GITHUB_ENV
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN || '' }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Get EC2 IPs (Dynamic Discovery with Exact Tag Match)
        id: get-ip
        run: |
          INSTANCE="${{ github.event.inputs.instance }}"
          
          # Map instance name to EXACT EC2 tag name
          case "$INSTANCE" in
            EC2_BASTION)
              TAG_NAME="EC-Bastion"
              ;;
            EC2_CORE)
              TAG_NAME="EC2-CORE"
              ;;
            EC2_DB)
              TAG_NAME="EC2-DB"
              ;;
            EC2_API_GATEWAY)
              TAG_NAME="EC2-API-Gateway"
              ;;
            EC2_FRONTEND)
              TAG_NAME="EC2-Frontend"
              ;;
            EC2_MESSAGING)
              TAG_NAME="EC2-Messaging"
              ;;
            EC2_MONITORING)
              TAG_NAME="EC2-Monitoring"
              ;;
            *)
              echo "‚ùå Unknown instance type: $INSTANCE"
              exit 1
              ;;
          esac
          
          echo "üîç Looking for instance with exact tag Name=$TAG_NAME"
          
          # Query EC2 for running instance with EXACT tag name match
          INSTANCE_DATA=$(aws ec2 describe-instances \
            --region $AWS_REGION \
            --filters "Name=instance-state-name,Values=running" "Name=tag:Name,Values=$TAG_NAME" \
            --query 'Reservations[0].Instances[0]' \
            --output json)
          
          if [ "$INSTANCE_DATA" = "null" ] || [ -z "$INSTANCE_DATA" ]; then
            echo "‚ùå ERROR: No running instance found with tag Name=$TAG_NAME"
            echo ""
            echo "Available running instances:"
            aws ec2 describe-instances \
              --region $AWS_REGION \
              --filters "Name=instance-state-name,Values=running" \
              --query 'Reservations[*].Instances[*].[Tags[?Key==`Name`].Value|[0],InstanceId,PublicIpAddress,State.Name]' \
              --output table
            exit 1
          fi
          
          # Extract values using exact jq queries
          PUBLIC_IP=$(echo "$INSTANCE_DATA" | jq -r '.PublicIpAddress // empty')
          PRIVATE_IP=$(echo "$INSTANCE_DATA" | jq -r '.PrivateIpAddress // empty')
          INSTANCE_ID=$(echo "$INSTANCE_DATA" | jq -r '.InstanceId // empty')
          INSTANCE_NAME=$(echo "$INSTANCE_DATA" | jq -r '.Tags[] | select(.Key=="Name") | .Value' | head -1)
          
          # Validate we got an IP
          if [ -z "$PUBLIC_IP" ] || [ "$PUBLIC_IP" = "null" ]; then
            echo "‚ùå ERROR: Could not get public IP for instance $TAG_NAME"
            exit 1
          fi
          
          echo "‚úÖ Found instance: $INSTANCE_NAME ($INSTANCE_ID)"
          echo "   Public IP (for SSH):  $PUBLIC_IP"
          echo "   Private IP (for routing): $PRIVATE_IP"
          
          echo "public_ip=$PUBLIC_IP" >> $GITHUB_OUTPUT
          echo "private_ip=$PRIVATE_IP" >> $GITHUB_OUTPUT
          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "instance_name=$INSTANCE_NAME" >> $GITHUB_OUTPUT
          
          # Export for use in other steps
          echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV
          echo "PRIVATE_IP=$PRIVATE_IP" >> $GITHUB_ENV
          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
          echo "INSTANCE_NAME=$INSTANCE_NAME" >> $GITHUB_ENV
      
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          # Use SSH key from repository secrets (base64 encoded)
          echo "${{ secrets.SSH_PRIVATE_KEY }}" | base64 -d > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ steps.get-ip.outputs.public_ip }} >> ~/.ssh/known_hosts 2>/dev/null || true
          echo "‚úÖ SSH setup complete for IP: ${{ steps.get-ip.outputs.public_ip }}"
      
      - name: Update Configuration with IPs
        run: |
          INSTANCE="${{ github.event.inputs.instance }}"
          PUBLIC_IP="${{ steps.get-ip.outputs.public_ip }}"
          PRIVATE_IP="${{ steps.get-ip.outputs.private_ip }}"
          
          echo "üîß Updating configuration files..."
          echo "   Using PUBLIC IP ($PUBLIC_IP) for SSH"
          echo "   Using PRIVATE IP ($PRIVATE_IP) for inter-service routing"
          
          # Update docker-compose.api-gateway.yml with Core private IP
          if [ "$INSTANCE" = "EC2_API_GATEWAY" ] && [ -f "./docker-compose.api-gateway.yml" ]; then
            echo "   Updating API Gateway config with CORE private IP..."
            # This will be done via script on EC2
          fi
          
          # For EC2_CORE: create a script that will update all .env files
          if [ "$INSTANCE" = "EC2_CORE" ]; then
            # Generate Python script to update .env files on EC2
            cat > /tmp/update-core-env.py << 'EOFPY'
import os
import glob

# .env files in microservices use localhost (internal Docker network)
# No changes needed for internal communication within core-net
print("‚úÖ Core services use internal Docker network - no IP changes needed for internal services")
EOFPY
          fi

      
      - name: Transfer files to EC2
        run: |
          PUBLIC_IP="${{ steps.get-ip.outputs.public_ip }}"
          PRIVATE_IP="${{ steps.get-ip.outputs.private_ip }}"
          INSTANCE="${{ github.event.inputs.instance }}"
          
          echo "üì¶ Transferring files to EC2 instance..."
          echo "   SSH via: $PUBLIC_IP"
          echo "   Instance routing IP: $PRIVATE_IP"
          
          # Aggressively clean space on EC2
          echo "üßπ Cleaning EC2 instance..."
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o ConnectTimeout=30 ubuntu@$PUBLIC_IP << CLEANUP
set -e
echo "=== Cleaning old docker resources ==="
docker system prune -af --volumes 2>/dev/null || true

echo "=== Cleaning old .tar files ==="
rm -f /tmp/*.tar /tmp/*.tar.gz 2>/dev/null || true
rm -f ~/docker-images/*.tar 2>/dev/null || true

echo "=== Disk usage before cleanup ==="
df -h / | tail -1

echo "=== Creating app directory ==="
mkdir -p ~/docker-images ~/app

echo "=== Disk usage after cleanup ==="
df -h / | tail -1
CLEANUP
          
          # Determine docker-compose.yml based on instance
          if [ "$INSTANCE" = "EC2_BASTION" ]; then
            echo "üì§ Transferring Bastion Host files..."
            scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o ConnectTimeout=30 -r ./bastion-host ubuntu@$PUBLIC_IP:~/app/bastion-host || true
            COMPOSE_FILE="./bastion-host/docker-compose.yml"
          elif [ "$INSTANCE" = "EC2_CORE" ]; then
            COMPOSE_FILE="./docker-compose.ec2-core.yml"
          elif [ "$INSTANCE" = "EC2_API_GATEWAY" ]; then
            # Special handling: Update docker-compose with CORE private IP
            echo "üîÑ Preparing API Gateway configuration..."
            # Will be done in deployment step
            COMPOSE_FILE="./docker-compose.api-gateway.yml"
          elif [ "$INSTANCE" = "EC2_FRONTEND" ]; then
            COMPOSE_FILE="./docker-compose.frontend.yml"
          elif [ "$INSTANCE" = "EC2_MESSAGING" ]; then
            COMPOSE_FILE="./messaging/docker-compose.yml"
          elif [ "$INSTANCE" = "EC2_MONITORING" ]; then
            COMPOSE_FILE="./monitoring/docker-compose.yml"
          elif [ "$INSTANCE" = "EC2_DB" ]; then
            COMPOSE_FILE="./databases/docker-compose.yml"
          else
            COMPOSE_FILE="./docker-compose.yml"
          fi
          
          if [ -f "$COMPOSE_FILE" ]; then
            scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o ConnectTimeout=30 "$COMPOSE_FILE" ubuntu@$PUBLIC_IP:~/app/docker-compose.yml
          else
            echo "‚ö†Ô∏è Warning: $COMPOSE_FILE not found, skipping docker-compose transfer"
          fi

      
      - name: Build Docker Images on EC2 (with Dynamic IP Configuration)
        run: |
          echo "üöÄ EXECUTING BUILD WITH DYNAMIC IP DISCOVERY"
          PUBLIC_IP="${{ steps.get-ip.outputs.public_ip }}"
          PRIVATE_IP="${{ steps.get-ip.outputs.private_ip }}"
          INSTANCE="${{ github.event.inputs.instance }}"
          GITHUB_REPO="${{ github.repository }}"
          GITHUB_REF="${{ github.ref }}"
          
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o ConnectTimeout=30 ubuntu@$PUBLIC_IP bash -s "$INSTANCE" "$PRIVATE_IP" "$GITHUB_REPO" "$GITHUB_REF" << 'BUILDSSH'
set -e
INSTANCE=$1
PRIVATE_IP=$2
GITHUB_REPO=$3
GITHUB_REF=$4

echo "================================================"
echo "üîß EC2 DEPLOYMENT WITH DYNAMIC IP CONFIGURATION"
echo "================================================"
echo "Instance Type: $INSTANCE"
echo "Private IP (for routing): $PRIVATE_IP"
echo "Repo: $GITHUB_REPO"
echo ""

# Step 1: Clone repository
echo "üì• Step 1: Cloning repository..."
cd ~
rm -rf app-build 2>/dev/null || true
git clone --depth 1 https://github.com/${GITHUB_REPO}.git app-build
cd app-build
git checkout ${GITHUB_REF#refs/heads/}
echo "‚úÖ Repository cloned"

# Step 2: Update configuration based on instance type
echo ""
echo "üîÑ Step 2: Updating configuration with Private IP ($PRIVATE_IP)..."

# For API Gateway: Update service URLs to use Core's private IP
if [ "$INSTANCE" = "EC2_API_GATEWAY" ]; then
  echo "   ‚Üí Configuring API Gateway to use CORE private IP..."
  
  # Check if we can find CORE instance
  # For now, use environment variable or manual configuration
  if [ -z "$CORE_PRIVATE_IP" ]; then
    echo "   ‚ö†Ô∏è CORE_PRIVATE_IP not set, using existing config"
  else
    if [ -f "./api-gateway/.env" ]; then
      sed -i "s|http://[0-9.]*:3000|http://$CORE_PRIVATE_IP:3000|g" "./api-gateway/.env"
      sed -i "s|http://[0-9.]*:3001|http://$CORE_PRIVATE_IP:3001|g" "./api-gateway/.env"
      sed -i "s|http://[0-9.]*:3002|http://$CORE_PRIVATE_IP:3002|g" "./api-gateway/.env"
      sed -i "s|http://[0-9.]*:5003|http://$CORE_PRIVATE_IP:5003|g" "./api-gateway/.env"
      sed -i "s|http://[0-9.]*:5004|http://$CORE_PRIVATE_IP:5004|g" "./api-gateway/.env"
      echo "   ‚úÖ API Gateway .env updated with CORE private IP"
    fi
  fi
  
  if [ -f "./docker-compose.api-gateway.yml" ]; then
    sed -i "s|http://[0-9.]*:3000|http://$PRIVATE_IP:3000|g" "./docker-compose.api-gateway.yml"
    sed -i "s|http://[0-9.]*:3001|http://$PRIVATE_IP:3001|g" "./docker-compose.api-gateway.yml"
    sed -i "s|http://[0-9.]*:3002|http://$PRIVATE_IP:3002|g" "./docker-compose.api-gateway.yml"
    sed -i "s|http://[0-9.]*:5003|http://$PRIVATE_IP:5003|g" "./docker-compose.api-gateway.yml"
    sed -i "s|http://[0-9.]*:5004|http://$PRIVATE_IP:5004|g" "./docker-compose.api-gateway.yml"
    echo "   ‚úÖ docker-compose.api-gateway.yml updated"
  fi
fi

# For EC2_CORE: Microservices use internal Docker network (localhost)
if [ "$INSTANCE" = "EC2_CORE" ]; then
  echo "   ‚Üí Core services use internal Docker network"
  echo "   ‚úÖ No IP changes needed (using localhost within core-net)"
fi

echo ""
echo "üèóÔ∏è  Step 3: Building Docker images..."
mkdir -p ~/docker-images

case "$INSTANCE" in
  EC2_BASTION)
    echo "   Building Bastion Host Docker image..."
    cd ~/app-build/bastion-host
    docker build --no-cache -t bastion-host:latest .
    ;;
  EC2_MESSAGING)
    echo "   Building infrastructure images for messaging..."
    cd ~/app-build
    if [ -f "./messaging/zookeeper/Dockerfile" ]; then
      echo "   ‚Üí Building zookeeper..."
      docker build --no-cache -t proyecto-zookeeper:1.0 -f ./messaging/zookeeper/Dockerfile ./messaging
    fi
    if [ -f "./messaging/kafka/Dockerfile" ]; then
      echo "   ‚Üí Building kafka..."
      docker build --no-cache -t proyecto-kafka:1.0 -f ./messaging/kafka/Dockerfile ./messaging
    fi
    if [ -f "./messaging/rabbitmq/Dockerfile" ]; then
      echo "   ‚Üí Building rabbitmq..."
      docker build --no-cache -t proyecto-rabbitmq:1.0 -f ./messaging/rabbitmq/Dockerfile ./messaging
    fi
    ;;
  EC2_MONITORING)
    echo "   Building infrastructure images for monitoring..."
    cd ~/app-build
    if [ -f "./monitoring/prometheus/Dockerfile" ]; then
      echo "   ‚Üí Building prometheus..."
      docker build --no-cache -t proyecto-prometheus:1.0 -f ./monitoring/prometheus/Dockerfile ./monitoring
    fi
    if [ -f "./monitoring/grafana/Dockerfile" ]; then
      echo "   ‚Üí Building grafana..."
      docker build --no-cache -t proyecto-grafana:1.0 -f ./monitoring/grafana/Dockerfile ./monitoring
    fi
    ;;
  *)
    echo "   Building microservices..."
    cd ~/app-build
    for SERVICE in api-gateway micro-auth micro-estudiantes micro-maestros frontend-web; do
      if [ -f "./$SERVICE/Dockerfile" ]; then
        echo "   ‚Üí Building $SERVICE..."
        if [ "$SERVICE" = "frontend-web" ]; then
          docker build --no-cache -t $SERVICE:latest -f ./$SERVICE/Dockerfile ./$SERVICE
        else
          docker build --no-cache -t $SERVICE:latest -f ./$SERVICE/Dockerfile .
        fi
      fi
    done
    ;;
esac

echo "‚úÖ Docker images built successfully"
echo ""
echo "üìä Available images:"
docker images | grep -E 'proyecto|api-gateway|micro|frontend' || echo "   No custom images found"

echo ""
echo "üöÄ Step 4: Starting services with docker-compose..."
cd ~/app
docker-compose down 2>/dev/null || true
sleep 2
docker-compose up -d

echo "‚è≥ Waiting for services to be ready (30 seconds)..."
sleep 30

echo ""
echo "üìã Service Status:"
docker-compose ps

echo ""
echo "üìù Recent logs (last 50 lines):"
docker-compose logs --tail=50 2>&1 || true

echo ""
echo "================================================"
echo "‚úÖ DEPLOYMENT COMPLETE"
echo "================================================"
BUILDSSH

      
      - name: Verify deployment
        if: always()
        continue-on-error: true
        run: |
          PUBLIC_IP="${{ steps.get-ip.outputs.public_ip }}"
          PRIVATE_IP="${{ steps.get-ip.outputs.private_ip }}"
          INSTANCE_NAME="${{ steps.get-ip.outputs.instance_name }}"
          
          echo "================================================"
          echo "üîç DEPLOYMENT VERIFICATION"
          echo "================================================"
          echo "Instance: $INSTANCE_NAME"
          echo "Public IP: $PUBLIC_IP"
          echo "Private IP: $PRIVATE_IP"
          echo ""
          
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o ConnectTimeout=30 ubuntu@$PUBLIC_IP bash << 'VERIFYSSH'
          
          echo "=== Verifying services status ==="
          cd ~/app
          docker-compose ps || true
          
          echo ""
          echo "=== Service logs (last 30 lines) ==="
          docker-compose logs --tail=30 2>&1 || echo "No logs available"
          
          echo ""
          echo "=== Checking resource usage ==="
          docker stats --no-stream | head -10 || true
          
          echo ""
          echo "================================================"
          echo "‚úÖ Deployment verification complete"
          echo "================================================"
          VERIFYSSH

