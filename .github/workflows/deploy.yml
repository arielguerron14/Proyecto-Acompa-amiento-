name: Deploy to EC2 (Dynamic IP Discovery)

on:
  workflow_dispatch:
    inputs:
      instance:
        description: 'Instance to deploy'
        required: true
        default: 'EC2_CORE'
        type: choice
        options:
          - EC2_BASTION
          - EC2_CORE
          - EC2_DB
          - EC2_API_GATEWAY
          - EC2_FRONTEND
          - EC2_MESSAGING
          - EC2_MONITORING
          - EC2_REPORTES
          - EC2_NOTIFICACIONES
          - EC2_ANALYTICS
          - ALL_INSTANCES
      rebuild_docker:
        description: 'Rebuild Docker images'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      build_location:
        description: 'Where to build images'
        required: false
        default: 'ec2'
        type: choice
        options:
          - 'ec2'
          - 'github'
      environment:
        description: 'Environment'
        required: true
        default: 'prod'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  AWS_REGION: us-east-1
  DOCKER_BUILDKIT: 1

jobs:
  deploy-ec2:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    permissions:
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set defaults for missing inputs
        id: defaults
        run: |
          REBUILD_DOCKER="${{ github.event.inputs.rebuild_docker || 'true' }}"
          BUILD_LOCATION="${{ github.event.inputs.build_location || 'ec2' }}"
          ENVIRONMENT="${{ github.event.inputs.environment || 'prod' }}"
          echo "rebuild_docker=${REBUILD_DOCKER}" >> $GITHUB_OUTPUT
          echo "build_location=${BUILD_LOCATION}" >> $GITHUB_OUTPUT
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          echo "REBUILD_DOCKER=${REBUILD_DOCKER}" >> $GITHUB_ENV
          echo "BUILD_LOCATION=${BUILD_LOCATION}" >> $GITHUB_ENV
          echo "ENVIRONMENT=${ENVIRONMENT}" >> $GITHUB_ENV
          echo "INSTANCE=${{ github.event.inputs.instance }}" >> $GITHUB_ENV
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Get EC2 IPs (Dynamic Discovery with Exact Tag Match)
        id: get-ip
        run: |
          INSTANCE="${{ github.event.inputs.instance }}"
          
          # Map instance name to EXACT EC2 tag name
          case "$INSTANCE" in
            EC2_BASTION)
              TAG_NAME="EC-Bastion"
              ;;
            EC2_CORE)
              TAG_NAME="EC2-CORE"
              ;;
            EC2_DB)
              TAG_NAME="EC2-DB"
              ;;
            EC2_API_GATEWAY)
              TAG_NAME="EC2-API-Gateway"
              ;;
            EC2_FRONTEND)
              TAG_NAME="EC2-Frontend"
              ;;
            EC2_MESSAGING)
              TAG_NAME="EC2-Messaging"
              ;;
            EC2_MONITORING)
              TAG_NAME="EC2-Monitoring"
              ;;
            EC2_REPORTES)
              TAG_NAME="EC2-Reportes"
              ;;
            EC2_NOTIFICACIONES)
              TAG_NAME="EC2-Notificaciones"
              ;;
            EC2_ANALYTICS)
              TAG_NAME="EC2-Analytics"
              ;;
            ALL_INSTANCES)
              echo "üîÑ Deploying to ALL instances..."
              TAG_NAME="*"
              ;;
            *)
              echo "‚ùå Unknown instance type: $INSTANCE"
              exit 1
              ;;
          esac
          
          echo "üîç Looking for instance with exact tag Name=$TAG_NAME"
          
          # Query EC2 for running instance with EXACT tag name match
          INSTANCE_DATA=$(aws ec2 describe-instances \
            --region $AWS_REGION \
            --filters "Name=instance-state-name,Values=running" "Name=tag:Name,Values=$TAG_NAME" \
            --query 'Reservations[0].Instances[0]' \
            --output json)
          
          if [ "$INSTANCE_DATA" = "null" ] || [ -z "$INSTANCE_DATA" ]; then
            echo "‚ùå ERROR: No running instance found with tag Name=$TAG_NAME"
            echo ""
            echo "Available running instances:"
            aws ec2 describe-instances \
              --region $AWS_REGION \
              --filters "Name=instance-state-name,Values=running" \
              --query 'Reservations[*].Instances[*].[Tags[?Key==`Name`].Value|[0],InstanceId,PublicIpAddress,State.Name]' \
              --output table
            exit 1
          fi
          
          # Extract values using exact jq queries
          PUBLIC_IP=$(echo "$INSTANCE_DATA" | jq -r '.PublicIpAddress // empty')
          PRIVATE_IP=$(echo "$INSTANCE_DATA" | jq -r '.PrivateIpAddress // empty')
          INSTANCE_ID=$(echo "$INSTANCE_DATA" | jq -r '.InstanceId // empty')
          INSTANCE_NAME=$(echo "$INSTANCE_DATA" | jq -r '.Tags[] | select(.Key=="Name") | .Value' | head -1)
          
          # Validate we got an IP
          if [ -z "$PUBLIC_IP" ] || [ "$PUBLIC_IP" = "null" ]; then
            echo "‚ùå ERROR: Could not get public IP for instance $TAG_NAME"
            exit 1
          fi
          
          echo "‚úÖ Found instance: $INSTANCE_NAME ($INSTANCE_ID)"
          echo "   Public IP (for SSH):  $PUBLIC_IP"
          echo "   Private IP (for routing): $PRIVATE_IP"
          
          echo "public_ip=$PUBLIC_IP" >> $GITHUB_OUTPUT
          echo "private_ip=$PRIVATE_IP" >> $GITHUB_OUTPUT
          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "instance_name=$INSTANCE_NAME" >> $GITHUB_OUTPUT
          
          # Export for use in other steps
          echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV
          echo "PRIVATE_IP=$PRIVATE_IP" >> $GITHUB_ENV
          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
          echo "INSTANCE_NAME=$INSTANCE_NAME" >> $GITHUB_ENV
      
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          # Use SSH key from repository secrets (plain text, not base64)
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ steps.get-ip.outputs.public_ip }} >> ~/.ssh/known_hosts 2>/dev/null || true
          echo "‚úÖ SSH setup complete for IP: ${{ steps.get-ip.outputs.public_ip }}"
      
      - name: Update Configuration with IPs
        run: |
          INSTANCE="${{ github.event.inputs.instance }}"
          PUBLIC_IP="${{ steps.get-ip.outputs.public_ip }}"
          PRIVATE_IP="${{ steps.get-ip.outputs.private_ip }}"
          
          echo "üîß Updating configuration files..."
          echo "   Using PUBLIC IP ($PUBLIC_IP) for SSH"
          echo "   Using PRIVATE IP ($PRIVATE_IP) for inter-service routing"
      
      - name: Transfer files to EC2
        run: |
          PUBLIC_IP="${{ steps.get-ip.outputs.public_ip }}"
          PRIVATE_IP="${{ steps.get-ip.outputs.private_ip }}"
          INSTANCE="${{ github.event.inputs.instance }}"
          
          echo "üì¶ Transferring files to EC2 instance..."
          echo "   SSH via: $PUBLIC_IP"
          echo "   Instance routing IP: $PRIVATE_IP"
          
          # Aggressively clean space on EC2
          echo "üßπ Cleaning EC2 instance..."
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o ConnectTimeout=30 ubuntu@$PUBLIC_IP '
          set -e
          echo "=== Cleaning old docker resources ==="
          docker system prune -af --volumes 2>/dev/null || true
          echo "=== Cleaning old .tar files ==="
          rm -f /tmp/*.tar /tmp/*.tar.gz 2>/dev/null || true
          rm -f ~/docker-images/*.tar 2>/dev/null || true
          echo "=== Creating app directory ==="
          mkdir -p ~/docker-images ~/app
          echo "‚úÖ EC2 cleaned and ready"
          '
          
          # Determine docker-compose.yml based on instance
          if [ "$INSTANCE" = "EC2_BASTION" ]; then
            echo "üì§ Transferring Bastion Host files..."
            scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o ConnectTimeout=30 -r ./bastion-host ubuntu@$PUBLIC_IP:~/app/bastion-host || true
            COMPOSE_FILE="./docker-compose.ec2-bastion.yml"
          elif [ "$INSTANCE" = "EC2_CORE" ]; then
            COMPOSE_FILE="./docker-compose.ec2-core.yml"
          elif [ "$INSTANCE" = "EC2_API_GATEWAY" ]; then
            COMPOSE_FILE="./docker-compose.api-gateway.yml"
          elif [ "$INSTANCE" = "EC2_FRONTEND" ]; then
            COMPOSE_FILE="./docker-compose.ec2-frontend.yml"
          elif [ "$INSTANCE" = "EC2_MESSAGING" ]; then
            COMPOSE_FILE="./docker-compose.ec2-messaging.yml"
          elif [ "$INSTANCE" = "EC2_MONITORING" ]; then
            COMPOSE_FILE="./docker-compose.ec2-monitoring.yml"
          elif [ "$INSTANCE" = "EC2_DB" ]; then
            COMPOSE_FILE="./docker-compose.ec2-db.yml"
          elif [ "$INSTANCE" = "EC2_REPORTES" ]; then
            COMPOSE_FILE="./docker-compose.ec2-reportes.yml"
          elif [ "$INSTANCE" = "EC2_NOTIFICACIONES" ]; then
            COMPOSE_FILE="./docker-compose.ec2-notificaciones.yml"
          elif [ "$INSTANCE" = "EC2_ANALYTICS" ]; then
            COMPOSE_FILE="./docker-compose.ec2-analytics.yml"
          else
            COMPOSE_FILE="./docker-compose.yml"
          fi
          
          if [ -f "$COMPOSE_FILE" ]; then
            scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o ConnectTimeout=30 "$COMPOSE_FILE" ubuntu@$PUBLIC_IP:~/app/docker-compose.yml
          else
            echo "‚ö†Ô∏è Warning: $COMPOSE_FILE not found, skipping docker-compose transfer"
          fi

      
      - name: Get EC2-CORE private IP (for API Gateway configuration)
        id: get-core-ip
        run: |
          INSTANCE="${{ github.event.inputs.instance }}"
          
          # If deploying to API Gateway, we need CORE's private IP
          if [[ "$INSTANCE" == "EC2_API_GATEWAY" || "$INSTANCE" == "ALL_INSTANCES" ]]; then
            echo "üîç Discovering EC2-CORE private IP for API Gateway configuration..."
            
            CORE_INSTANCE=$(aws ec2 describe-instances \
              --region $AWS_REGION \
              --filters "Name=instance-state-name,Values=running" "Name=tag:Name,Values=EC2-CORE" \
              --query 'Reservations[0].Instances[0]' \
              --output json)
            
            if [ "$CORE_INSTANCE" != "null" ] && [ -n "$CORE_INSTANCE" ]; then
              CORE_PRIVATE_IP=$(echo $CORE_INSTANCE | jq -r '.PrivateIpAddress')
              echo "‚úÖ Found EC2-CORE at private IP: $CORE_PRIVATE_IP"
              echo "core_private_ip=$CORE_PRIVATE_IP" >> $GITHUB_OUTPUT
            else
              echo "‚ö†Ô∏è Warning: EC2-CORE not found. API Gateway will use existing configuration."
              echo "core_private_ip=NOT_FOUND" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ÑπÔ∏è Not deploying to API Gateway, skipping CORE IP discovery"
            echo "core_private_ip=NOT_NEEDED" >> $GITHUB_OUTPUT
          fi



      - name: Build Docker Images on EC2 (with Dynamic IP Configuration)
        run: |
          echo "üöÄ EXECUTING BUILD WITH DYNAMIC IP DISCOVERY"
          PUBLIC_IP="${{ steps.get-ip.outputs.public_ip }}"
          PRIVATE_IP="${{ steps.get-ip.outputs.private_ip }}"
          INSTANCE="${{ github.event.inputs.instance }}"
          GITHUB_REPO="${{ github.repository }}"
          GITHUB_REF="${{ github.ref }}"
          CORE_PRIVATE_IP="${{ steps.get-core-ip.outputs.core_private_ip }}"
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o ConnectTimeout=30 ubuntu@$PUBLIC_IP bash -s <<'BUILDSSH'
          set -e
          INSTANCE="$INSTANCE"
          PRIVATE_IP="$PRIVATE_IP"
          GITHUB_REPO="$GITHUB_REPO"
          GITHUB_REF="$GITHUB_REF"
          CORE_PRIVATE_IP="$CORE_PRIVATE_IP"
          echo "================================================"
          echo "üîß EC2 DEPLOYMENT WITH DYNAMIC IP CONFIGURATION"
          echo "================================================"
          echo "Instance Type: $INSTANCE"
          echo "Private IP (for routing): $PRIVATE_IP"
          echo "Repo: $GITHUB_REPO"
          echo ""
          # Step 1: Clone repository
          echo "üì• Step 1: Cloning repository..."
          cd ~
          rm -rf app-build 2>/dev/null || true
          git clone --depth 1 https://github.com/${GITHUB_REPO}.git app-build
          cd app-build
          git checkout ${GITHUB_REF#refs/heads/}
          echo "‚úÖ Repository cloned"
          # Step 2: Update configuration based on instance type
          echo ""
          echo "üîÑ Step 2: Updating configuration with Private IP ($PRIVATE_IP)..."
          # For API Gateway: Update service URLs to use Core's private IP
          if [ "$INSTANCE" = "EC2_API_GATEWAY" ]; then
            echo "   ‚Üí Configuring API Gateway to use CORE private IP..."
            if [ "$CORE_PRIVATE_IP" != "NOT_FOUND" ] && [ "$CORE_PRIVATE_IP" != "NOT_NEEDED" ] && [ -n "$CORE_PRIVATE_IP" ]; then
              echo "   ‚úÖ Using CORE_PRIVATE_IP: $CORE_PRIVATE_IP"
              # Update docker-compose.api-gateway.yml with CORE private IP (no port in CORE_HOST)
              if [ -f "./docker-compose.api-gateway.yml" ]; then
                sed -i "s|CORE_HOST: .*|CORE_HOST: \"http://$CORE_PRIVATE_IP\"|g" "./docker-compose.api-gateway.yml"
                echo "   ‚úÖ docker-compose.api-gateway.yml updated with CORE_HOST"
              fi
              # Update api-gateway .env if it exists
              if [ -f "./api-gateway/.env" ]; then
                sed -i "s|CORE_HOST=.*|CORE_HOST=http://$CORE_PRIVATE_IP|g" "./api-gateway/.env"
                echo "   ‚úÖ api-gateway .env updated"
              fi
            else
              echo "   ‚ö†Ô∏è CORE_PRIVATE_IP not available ($CORE_PRIVATE_IP), using default docker-compose configuration"
            fi
          fi
          # For EC2_CORE: Microservices use internal Docker network (localhost)
          if [ "$INSTANCE" = "EC2_CORE" ]; then
            echo "   ‚Üí Core services use internal Docker network"
            echo "   ‚úÖ No IP changes needed (using localhost within core-net)"
          fi
          echo ""
          echo "üèóÔ∏è  Step 3: Building Docker images..."
          mkdir -p ~/docker-images
          case "$INSTANCE" in
            EC2_BASTION)
              echo "   Building Bastion Host Docker image..."
               # cd ~/app-build/bastion-host
              docker build --no-cache -t bastion-host:latest .
              ;;
            EC2_CORE)
              echo "   Building Core microservices (auth, estudiantes, maestros, core)..."
               # cd ~/app-build
              for SERVICE in micro-auth micro-estudiantes micro-maestros micro-core; do
                if [ -f "./$SERVICE/Dockerfile" ]; then
                  echo "   ‚Üí Building $SERVICE..."
                  docker build --no-cache -t $SERVICE:latest -f ./$SERVICE/Dockerfile .
                fi
              done
              ;;
            EC2_API_GATEWAY)
              echo "   Building API Gateway Docker image..."
               # cd ~/app-build
              if [ -f "./api-gateway/Dockerfile" ]; then
                docker build --no-cache -t api-gateway:latest -f ./api-gateway/Dockerfile .
              fi
              ;;
            EC2_REPORTES)
              echo "   Building Reportes microservices..."
               # cd ~/app-build
              for SERVICE in micro-reportes-estudiantes micro-reportes-maestros; do
                if [ -f "./$SERVICE/Dockerfile" ]; then
                  echo "   ‚Üí Building $SERVICE..."
                  docker build --no-cache -t $SERVICE:latest -f ./$SERVICE/Dockerfile .
                fi
              done
              ;;
            EC2_NOTIFICACIONES)
              echo "   Building Notificaciones microservice..."
               # cd ~/app-build
              if [ -f "./micro-notificaciones/Dockerfile" ]; then
                docker build --no-cache -t micro-notificaciones:latest -f ./micro-notificaciones/Dockerfile .
              fi
              ;;
            EC2_MESSAGING)
              echo "   Building infrastructure images for messaging..."
               # cd ~/app-build
              if [ -f "./messaging/zookeeper/Dockerfile" ]; then
                echo "   ‚Üí Building zookeeper..."
                docker build --no-cache -t proyecto-zookeeper:1.0 -f ./messaging/zookeeper/Dockerfile ./messaging
              fi
              if [ -f "./messaging/kafka/Dockerfile" ]; then
                echo "   ‚Üí Building kafka..."
                docker build --no-cache -t proyecto-kafka:1.0 -f ./messaging/kafka/Dockerfile ./messaging
              fi
              if [ -f "./messaging/rabbitmq/Dockerfile" ]; then
                echo "   ‚Üí Building rabbitmq..."
                docker build --no-cache -t proyecto-rabbitmq:1.0 -f ./messaging/rabbitmq/Dockerfile ./messaging
              fi
              ;;
            EC2_DB)
              echo "   ‚ÑπÔ∏è Database instance (mongo, postgres, redis) - no custom builds needed"
              echo "   Using pre-built Docker Hub images"
              ;;
            EC2_ANALYTICS)
              echo "   Building Analytics microservice..."
              if [ -f "~/app-build/micro-analytics/Dockerfile" ]; then
                docker build --no-cache -t micro-analytics:latest -f ~/app-build/micro-analytics/Dockerfile ~/app-build
              fi
              ;;
            EC2_MONITORING)
              echo "   Building infrastructure images for monitoring..."
               # cd ~/app-build
              if [ -f "./monitoring/prometheus/Dockerfile" ]; then
                echo "   ‚Üí Building prometheus..."
                docker build --no-cache -t proyecto-prometheus:1.0 -f ./monitoring/prometheus/Dockerfile ./monitoring
              fi
              if [ -f "./monitoring/grafana/Dockerfile" ]; then
                echo "   ‚Üí Building grafana..."
                docker build --no-cache -t proyecto-grafana:1.0 -f ./monitoring/grafana/Dockerfile ./monitoring
              fi
              ;;
            EC2_FRONTEND)
              echo "   Building Frontend Docker image..."
               # cd ~/app-build
              if [ -f "./frontend-web/Dockerfile" ]; then
                docker build --no-cache -t frontend-web:latest -f ./frontend-web/Dockerfile ./frontend-web
              fi
              ;;
            ALL_INSTANCES)
              echo "   Building ALL microservices and infrastructure..."
               # cd ~/app-build
              echo "   ‚Üí Building Bastion..."
              cd bastion-host && docker build --no-cache -t bastion-host:latest . && cd ..
              echo "   ‚Üí Building Core services..."
              for SERVICE in micro-auth micro-estudiantes micro-maestros micro-core; do
                if [ -f "./$SERVICE/Dockerfile" ]; then
                  docker build --no-cache -t $SERVICE:latest -f ./$SERVICE/Dockerfile .
                fi
              done
              echo "   ‚Üí Building API Gateway..."
              if [ -f "./api-gateway/Dockerfile" ]; then
                docker build --no-cache -t api-gateway:latest -f ./api-gateway/Dockerfile .
              fi
              echo "   ‚Üí Building Reportes services..."
              for SERVICE in micro-reportes-estudiantes micro-reportes-maestros; do
                if [ -f "./$SERVICE/Dockerfile" ]; then
                  docker build --no-cache -t $SERVICE:latest -f ./$SERVICE/Dockerfile .
                fi
              done
              echo "   ‚Üí Building Notificaciones..."
              if [ -f "./micro-notificaciones/Dockerfile" ]; then
                docker build --no-cache -t micro-notificaciones:latest -f ./micro-notificaciones/Dockerfile .
              fi
              echo "   ‚Üí Building Analytics..."
              if [ -f "./micro-analytics/Dockerfile" ]; then
                docker build --no-cache -t micro-analytics:latest -f ./micro-analytics/Dockerfile .
              fi
              echo "   ‚Üí Building Messaging infrastructure..."
              if [ -f "./messaging/zookeeper/Dockerfile" ]; then
                docker build --no-cache -t proyecto-zookeeper:1.0 -f ./messaging/zookeeper/Dockerfile ./messaging
              fi
              if [ -f "./messaging/kafka/Dockerfile" ]; then
                docker build --no-cache -t proyecto-kafka:1.0 -f ./messaging/kafka/Dockerfile ./messaging
              fi
              if [ -f "./messaging/rabbitmq/Dockerfile" ]; then
                docker build --no-cache -t proyecto-rabbitmq:1.0 -f ./messaging/rabbitmq/Dockerfile ./messaging
              fi
              echo "   ‚Üí Building Monitoring infrastructure..."
              if [ -f "./monitoring/prometheus/Dockerfile" ]; then
                docker build --no-cache -t proyecto-prometheus:1.0 -f ./monitoring/prometheus/Dockerfile ./monitoring
              fi
              if [ -f "./monitoring/grafana/Dockerfile" ]; then
                docker build --no-cache -t proyecto-grafana:1.0 -f ./monitoring/grafana/Dockerfile ./monitoring
              fi
              echo "   ‚Üí Building Frontend..."
              if [ -f "./frontend-web/Dockerfile" ]; then
                docker build --no-cache -t frontend-web:latest -f ./frontend-web/Dockerfile ./frontend-web
              fi
              ;;
          esac
          echo "‚úÖ Docker images built successfully"
          echo ""
          echo "üìä Available images:"
          docker images | grep -E 'proyecto|api-gateway|micro|frontend' || echo "   No custom images found"
          echo ""
          echo "üöÄ Step 4: Starting services with docker-compose..."
          cd ~/app
          docker-compose down 2>/dev/null || true
          sleep 2
          docker-compose up -d
          echo "‚è≥ Waiting for services to be ready (30 seconds)..."
          sleep 30
          echo ""
          echo "üìã Service Status:"
          docker-compose ps
          echo ""
          echo "üìù Recent logs (last 50 lines):"
          docker-compose logs --tail=50 2>&1 || true
          echo ""
          echo "================================================"
          echo "‚úÖ DEPLOYMENT COMPLETE"
          echo "================================================"
          BUILDSSH

      
      - name: Verify deployment
        if: always()
        continue-on-error: true
        run: |
          PUBLIC_IP="${{ steps.get-ip.outputs.public_ip }}"
          PRIVATE_IP="${{ steps.get-ip.outputs.private_ip }}"
          INSTANCE_NAME="${{ steps.get-ip.outputs.instance_name }}"
          echo "================================================"
          echo "üîç DEPLOYMENT VERIFICATION"
          echo "================================================"
          echo "Instance: $INSTANCE_NAME"
          echo "Public IP: $PUBLIC_IP"
          echo "Private IP: $PRIVATE_IP"
          echo ""
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o ConnectTimeout=30 ubuntu@$PUBLIC_IP bash << 'VERIFYSSH'
          set -e
          echo "=== Verifying services status ==="
          cd ~/app || { echo "[ERROR] ~/app no existe"; exit 0; }
          docker-compose ps || echo "[ERROR] docker-compose ps fall√≥"
          echo ""
          echo "=== Service logs (last 30 lines) ==="
          docker-compose logs --tail=30 2>&1 || echo "No logs available"
          echo ""
          echo "=== Checking resource usage ==="
          docker stats --no-stream | head -10 || echo "No stats available"
          echo ""
          echo "================================================"
          echo "‚úÖ Deployment verification complete"
          echo "================================================"
          VERIFYSSH

