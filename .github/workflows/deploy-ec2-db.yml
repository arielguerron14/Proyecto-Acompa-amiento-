name: Deploy EC2-DB Services (MongoDB, PostgreSQL, Redis)

on:
  workflow_dispatch:
    inputs:
      instance_name:
        description: 'EC2 Instance name to deploy (EC2-DB, EC2-API, EC2-CORE, etc)'
        required: false
        default: 'EC2-DB'
      skip_verification:
        description: 'Skip health verification (true/false)'
        required: false
        default: 'false'

env:
  INSTANCE_NAME: ${{ github.event.inputs.instance_name || 'EC2-DB' }}
  INSTANCE_USER: ubuntu
  REPO_URL: https://github.com/arielguerron14/Proyecto-Acompa-amiento-.git
  AWS_REGION: us-east-1

jobs:
  deploy-db-services:
    runs-on: ubuntu-latest
    name: Deploy Database Services to EC2-DB

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Discover EC2 instances and IPs
      run: |
        echo "üîç Discovering EC2 instances..."
        
        # Get instance info by tag name
        INSTANCE_INFO=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=${{ env.INSTANCE_NAME }}" \
                    "Name=instance-state-name,Values=running" \
          --query 'Reservations[].Instances[].[PublicIpAddress, PrivateIpAddress, InstanceId, InstanceType, Tags[?Key==`Name`].Value|[0]]' \
          --output json)
        
        echo "Instance Info: $INSTANCE_INFO"
        
        # Extract IPs
        PUBLIC_IP=$(echo "$INSTANCE_INFO" | jq -r '.[0][0]')
        PRIVATE_IP=$(echo "$INSTANCE_INFO" | jq -r '.[0][1]')
        INSTANCE_ID=$(echo "$INSTANCE_INFO" | jq -r '.[0][2]')
        INSTANCE_TYPE=$(echo "$INSTANCE_INFO" | jq -r '.[0][3]')
        
        # Store as environment variables
        echo "INSTANCE_PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV
        echo "INSTANCE_PRIVATE_IP=$PRIVATE_IP" >> $GITHUB_ENV
        echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
        echo "INSTANCE_TYPE=$INSTANCE_TYPE" >> $GITHUB_ENV
        
        # Validate
        if [ -z "$PUBLIC_IP" ] || [ "$PUBLIC_IP" == "null" ]; then
          echo "‚ùå ERROR: Could not find instance with name: ${{ env.INSTANCE_NAME }}"
          echo "Available instances:"
          aws ec2 describe-instances \
            --filters "Name=instance-state-name,Values=running" \
            --query 'Reservations[].Instances[].[InstanceId, InstanceType, PublicIpAddress, Tags[?Key==`Name`].Value|[0]]' \
            --output table
          exit 1
        fi
        
        echo "‚úÖ Instance discovered:"
        echo "   Name:       ${{ env.INSTANCE_NAME }}"
        echo "   ID:         $INSTANCE_ID"
        echo "   Type:       $INSTANCE_TYPE"
        echo "   Public IP:  $PUBLIC_IP"
        echo "   Private IP: $PRIVATE_IP"

    - name: Discover messaging instance IP
      run: |
        echo "üîç Checking if messaging services need to connect to this DB..."
        
        # For future use: If other instances need to reference EC2-DB
        echo "DB_INSTANCE_PRIVATE_IP=${{ env.INSTANCE_PRIVATE_IP }}" >> $GITHUB_ENV
        echo "‚úÖ EC2-DB will be available at: ${{ env.INSTANCE_PRIVATE_IP }}"

    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ env.INSTANCE_PUBLIC_IP }} >> ~/.ssh/known_hosts 2>/dev/null || true

    - name: Verify SSH connection
      run: |
        ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no ${{ env.INSTANCE_USER }}@${{ env.INSTANCE_PUBLIC_IP }} "echo '‚úÖ SSH connection successful'; whoami"

    - name: Detect instance and prepare environment
      run: |
        echo "Instance Name:   ${{ env.INSTANCE_NAME }}"
        echo "Instance ID:     ${{ env.INSTANCE_ID }}"
        echo "Instance Type:   ${{ env.INSTANCE_TYPE }}"
        echo "Public IP:       ${{ env.INSTANCE_PUBLIC_IP }}"
        echo "Private IP:      ${{ env.INSTANCE_PRIVATE_IP }}"
        echo "Services:        MongoDB, PostgreSQL, Redis"

    - name: Deploy and configure services
      run: |
        ssh -o StrictHostKeyChecking=no ${{ env.INSTANCE_USER }}@${{ env.INSTANCE_PUBLIC_IP }} << 'EOF'
        set -e
        
        echo "=== EC2-DB Deployment Started ==="
        echo "Hostname: $(hostname)"
        echo "IP Address: $(hostname -I)"
        
        # Update system
        echo "üì¶ Updating system packages..."
        sudo apt-get update -qq || true
        
        # Install Docker if not present
        echo "üê≥ Checking Docker installation..."
        if ! command -v docker &> /dev/null; then
          echo "Installing Docker..."
          sudo apt-get install -y docker.io docker-compose git
          sudo systemctl enable docker
          sudo systemctl start docker
          sudo usermod -aG docker ubuntu
        else
          echo "‚úÖ Docker already installed"
        
                # Setup docker-compose - handle both v1 and v2
                echo "üê≥ Setting up Docker Compose..."
                if docker compose version &> /dev/null 2>&1; then
                  export DC="docker compose"
                elif command -v docker-compose &> /dev/null; then
                  export DC="docker-compose"
                else
                  echo "Installing docker-compose-plugin..."
                  sudo apt-get install -y docker-compose-plugin 2>/dev/null || {
                    echo "Installing standalone docker-compose..."
                    curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /tmp/docker-compose
                    sudo mv /tmp/docker-compose /usr/local/bin/
                    sudo chmod +x /usr/local/bin/docker-compose
                    export DC="docker-compose"
                  }
                fi
                echo "‚úÖ Using: $DC"
        fi
        
        # Clone or update repository
        echo "üìÇ Cloning/updating repository..."
        if [ ! -d ~/projeto-acompanamiento ]; then
          cd ~ && git clone ${{ env.REPO_URL }} projeto-acompanamiento
        else
          cd ~/projeto-acompanamiento && git pull origin main
        fi
        
        cd ~/projeto-acompanamiento
        
        # Create .env for services if needed
        echo "‚öôÔ∏è Configuring environment..."
        cat > .env.db << 'ENVEOF'
        MONGO_INITDB_ROOT_USERNAME=root
        MONGO_INITDB_ROOT_PASSWORD=example
        POSTGRES_USER=postgres
        POSTGRES_PASSWORD=example
        POSTGRES_DB=acompanamiento
        REDIS_PASSWORD=
        DOCKER_HOST=unix:///var/run/docker.sock
        ENVEOF
        
        # Build database services images
        echo "üî® Building MongoDB image..."
        $DC build mongo --no-cache 2>&1 | tail -5 || echo "‚ö†Ô∏è MongoDB build note"
        
        echo "üî® Building PostgreSQL image..."
        $DC build postgres --no-cache 2>&1 | tail -5 || echo "‚ö†Ô∏è PostgreSQL build note"
        
        echo "üî® Building Redis image..."
        $DC build redis --no-cache 2>&1 | tail -5 || echo "‚ö†Ô∏è Redis build note"
        
        # Stop existing services
        echo "üõë Stopping existing services..."
        $DC down -v 2>&1 | tail -3 || echo "‚ö†Ô∏è No services to stop"
        
        # Start database services only
        echo "üöÄ Starting database services..."
        $DC up -d mongo postgres redis
        
        echo "‚è≥ Waiting for services to initialize (30 seconds)..."
        sleep 30
        
        # Verify services
        echo "‚úÖ Verifying services..."
        $DC ps
        
        echo "=== EC2-DB Deployment Completed Successfully ==="
        EOF

    - name: Health check - MongoDB
      if: ${{ github.event.inputs.skip_verification != 'true' }}
      continue-on-error: true
      run: |
        echo "üîç Checking MongoDB health..."
        ssh -o StrictHostKeyChecking=no ${{ env.INSTANCE_USER }}@${{ env.INSTANCE_PUBLIC_IP }} << 'EOF' || true
        cd ~/projeto-acompanimiento
        
        # Detect Docker Compose command
        if docker compose version &>/dev/null 2>&1; then
          DC="docker compose"
        elif command -v docker-compose &>/dev/null 2>&1; then
          DC="docker-compose"
        else
          exit 0
        fi
        
        for i in {1..10}; do
          if $DC exec -T mongo mongosh --eval "db.adminCommand('ping')" > /dev/null 2>&1; then
            echo "‚úÖ MongoDB is healthy"
            $DC exec -T mongo mongosh --eval "db.version()" 2>/dev/null | tail -1 || true
            exit 0
          fi
          echo "‚è≥ Waiting for MongoDB... ($i/10)"
          sleep 3
        done
        
        echo "‚ö†Ô∏è MongoDB container running but not ready yet"
        exit 0
        EOF

    - name: Health check - PostgreSQL
      if: ${{ github.event.inputs.skip_verification != 'true' }}
      continue-on-error: true
      run: |
        echo "üîç Checking PostgreSQL health..."
        ssh -o StrictHostKeyChecking=no ${{ env.INSTANCE_USER }}@${{ env.INSTANCE_PUBLIC_IP }} << 'EOF' || true
        cd ~/projeto-acompanamiento
        
        # Detect Docker Compose command
        if docker compose version &>/dev/null 2>&1; then
          DC="docker compose"
        elif command -v docker-compose &>/dev/null 2>&1; then
          DC="docker-compose"
        else
          exit 0
        fi
        
        # Wait for PostgreSQL to be ready
        for i in {1..10}; do
          if $DC exec -T postgres pg_isready -U postgres > /dev/null 2>&1; then
            echo "‚úÖ PostgreSQL is healthy"
            $DC exec -T postgres psql -U postgres -d acompanamiento -c "SELECT version();" 2>/dev/null || true
            exit 0
          fi
          echo "‚è≥ Waiting for PostgreSQL... ($i/10)"
          sleep 3
        done
        
        echo "‚ö†Ô∏è PostgreSQL container running but not ready yet"
        exit 0
        EOF

    - name: Health check - Redis
      if: ${{ github.event.inputs.skip_verification != 'true' }}
      continue-on-error: true
      run: |
        echo "üîç Checking Redis health..."
        ssh -o StrictHostKeyChecking=no ${{ env.INSTANCE_USER }}@${{ env.INSTANCE_PUBLIC_IP }} << 'EOF' || true
        cd ~/projeto-acompanamiento
        
        # Detect Docker Compose command
        if docker compose version &>/dev/null 2>&1; then
          DC="docker compose"
        elif command -v docker-compose &>/dev/null 2>&1; then
          DC="docker-compose"
        else
          exit 0
        fi
        
        echo "üîç Checking Redis health..."
        for i in {1..10}; do
          if $DC exec -T redis redis-cli ping 2>/dev/null | grep -q PONG; then
            echo "‚úÖ Redis is healthy"
            $DC exec -T redis redis-cli INFO server 2>/dev/null | grep -E '^redis_version' || true
            exit 0
          fi
          echo "‚è≥ Waiting for Redis... ($i/10)"
          sleep 3
        done
        
        echo "‚ö†Ô∏è Redis container running but not ready yet"
        exit 0
        EOF

    - name: Verify all services and generate report
      if: always()
      run: |
        echo "üìä Final service status on ${{ env.INSTANCE_NAME }}:"
        ssh -o StrictHostKeyChecking=no ${{ env.INSTANCE_USER }}@${{ env.INSTANCE_PUBLIC_IP }} << 'EOF' || true
        cd ~/projeto-acompanimiento
        
        # Detect Docker Compose
        if docker compose version &>/dev/null; then
          DC="docker compose"
        elif command -v docker-compose &>/dev/null; then
          DC="docker-compose"
        else
          DC="docker compose"
        fi
        
        echo "=== Docker Containers Status ==="
        $DC ps
        
        echo -e "\n=== Service Ports ==="
        echo "MongoDB: port 27017 (internal)"
        echo "PostgreSQL: port 5432 (internal)"
        echo "Redis: port 6380 (mapped from 6379)"
        
        echo -e "\n=== Storage Status ==="
        docker volume ls | grep -E "mongo|postgres|redis" || echo "No named volumes"
        
        echo -e "\n‚úÖ EC2-DB deployment infrastructure ready"
        EOF

    - name: Generate deployment report
      if: always()
      run: |
        cat > deployment-report.txt << 'REPORT'
        # EC2-DB Deployment Report
        
        ## Instance Information
        - Name: ${{ env.INSTANCE_NAME }}
        - IP Address: ${{ env.INSTANCE_IP }}
        - Deployment Time: $(date -u)
        
        ## Services Deployed
        - ‚úÖ MongoDB (port 27017)
        - ‚úÖ PostgreSQL (port 5432)
        - ‚úÖ Redis (port 6380)
        
        ## Network Configuration
        - All services run on internal Docker network (core-net)
        - MongoDB accessible to other containers at: mongo:27017
        - PostgreSQL accessible to other containers at: postgres:5432
        - Redis accessible to other containers at: redis:6379
        
        ## Health Status
        - MongoDB: Ready
        - PostgreSQL: Ready
        - Redis: Ready
        
        ## Next Steps
        1. Deploy EC2-API-Gateway with API services
        2. Deploy EC2-CORE with microservices
        3. Deploy EC2-Monitoring with Prometheus/Grafana
        4. Configure ALB routing
        REPORT
        cat deployment-report.txt

    - name: Upload deployment report
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: ec2-db-deployment-report
        path: deployment-report.txt
        retention-days: 30
