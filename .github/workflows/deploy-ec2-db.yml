name: ğŸš€ Deploy EC2-DB (MongoDB, PostgreSQL, Redis)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
          - development

env:
  EC2_DB_PUBLIC_IP: 44.200.84.224
  EC2_DB_PRIVATE_IP: 172.31.79.193
  SSH_USER: ubuntu
  AWS_REGION: us-east-1

jobs:
  deploy-ec2-db:
    name: Deploy EC2-DB Databases
    runs-on: ubuntu-latest
    
    steps:
      # 1. Checkout code
      - name: âœ… Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 2. Setup SSH
      - name: ğŸ”‘ Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.AWS_EC2_DB_SSH_PRIVATE_KEY }}" > ~/.ssh/aws-key.pem
          chmod 600 ~/.ssh/aws-key.pem
          ssh-keyscan -H ${{ env.EC2_DB_PUBLIC_IP }} >> ~/.ssh/known_hosts 2>/dev/null || true

      # 3. Test SSH Connection
      - name: ğŸ”— Test SSH Connection to EC2-DB
        run: |
          echo "Testing connection to EC2-DB..."
          ssh -i ~/.ssh/aws-key.pem \
            -o ConnectTimeout=10 \
            -o StrictHostKeyChecking=no \
            ${{ env.SSH_USER }}@${{ env.EC2_DB_PUBLIC_IP }} \
            "echo 'âœ… SSH Connection Successful'"

      # 4. Prepare EC2 Instance
      - name: ğŸ“¦ Prepare EC2-DB Instance
        run: |
          echo "ğŸ”§ Installing Docker and dependencies..."
          ssh -i ~/.ssh/aws-key.pem \
            -o StrictHostKeyChecking=no \
            ${{ env.SSH_USER }}@${{ env.EC2_DB_PUBLIC_IP }} << 'EOF'
            
            set -e
            
            echo "ğŸ“ Updating system packages..."
            sudo apt-get update -y > /dev/null 2>&1
            
            echo "ğŸ“¦ Installing Docker..."
            sudo apt-get install -y docker.io > /dev/null 2>&1
            
            echo "ğŸ”§ Starting Docker service..."
            sudo systemctl start docker
            sudo systemctl enable docker > /dev/null 2>&1
            
            echo "ğŸ‘¤ Adding user to docker group..."
            sudo usermod -aG docker ubuntu > /dev/null 2>&1
            
            echo "ğŸ³ Installing Docker Compose..."
            DOCKER_COMPOSE_VERSION=$(curl -s https://api.github.com/repos/docker/compose/releases/latest | grep -oP '"tag_name": "\K[^"]+')
            sudo curl -sL "https://github.com/docker/compose/releases/download/${DOCKER_COMPOSE_VERSION}/docker-compose-$(uname -s)-$(uname -m)" \
              -o /usr/local/bin/docker-compose 2>/dev/null || \
            sudo curl -sL "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" \
              -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
            
            echo "âœ… EC2-DB Instance Prepared"
            docker-compose --version
            docker --version
          EOF

      # 5. Copy docker-compose file
      - name: ğŸ“„ Copy Docker Compose Configuration
        run: |
          echo "ğŸ“‹ Creating databases directory on EC2-DB..."
          ssh -i ~/.ssh/aws-key.pem \
            -o StrictHostKeyChecking=no \
            ${{ env.SSH_USER }}@${{ env.EC2_DB_PUBLIC_IP }} \
            "sudo mkdir -p /opt/databases && sudo chown ubuntu:ubuntu /opt/databases && cd /opt/databases && pwd"
          
          # Create docker-compose on remote server
          ssh -i ~/.ssh/aws-key.pem \
            -o StrictHostKeyChecking=no \
            ${{ env.SSH_USER }}@${{ env.EC2_DB_PUBLIC_IP }} << 'COMPOSE_EOF'
          
          cat > /opt/databases/docker-compose.yml << 'DOCKER_COMPOSE'
          services:
            mongodb:
              image: mongo:6.0
              container_name: mongodb
              ports:
                - "27017:27017"
              environment:
                MONGO_INITDB_ROOT_USERNAME: admin
                MONGO_INITDB_ROOT_PASSWORD: mongodb123
              volumes:
                - mongodb_data:/data/db
              networks:
                - databases
              restart: unless-stopped
              healthcheck:
                test: echo 'db.runCommand("ping").ok' | mongosh localhost:27017/test --quiet
                interval: 10s
                timeout: 5s
                retries: 3
          
            postgresql:
              image: postgres:15
              container_name: postgresql
              ports:
                - "5432:5432"
              environment:
                POSTGRES_USER: postgres
                POSTGRES_PASSWORD: postgres123
                POSTGRES_DB: acompanamiento
              volumes:
                - postgresql_data:/var/lib/postgresql/data
              networks:
                - databases
              restart: unless-stopped
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U postgres"]
                interval: 10s
                timeout: 5s
                retries: 3
          
            redis:
              image: redis:7-alpine
              container_name: redis
              ports:
                - "6379:6379"
              command: redis-server --appendonly yes --requirepass redis123
              volumes:
                - redis_data:/data
              networks:
                - databases
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "redis-cli", "ping"]
                interval: 10s
                timeout: 5s
                retries: 3
          
          volumes:
            mongodb_data:
            postgresql_data:
            redis_data:
          
          networks:
            databases:
              driver: bridge
          DOCKER_COMPOSE
          
          echo "âœ… docker-compose.yml created"
          COMPOSE_EOF

      # 6. Create .env file
      - name: ğŸ” Create Environment Configuration
        run: |
          ssh -i ~/.ssh/aws-key.pem \
            -o StrictHostKeyChecking=no \
            ${{ env.SSH_USER }}@${{ env.EC2_DB_PUBLIC_IP }} << 'ENV_EOF'
          
          cat > /opt/databases/.env << 'ENV_CONTENT'
          # Database Credentials
          MONGO_INITDB_ROOT_USERNAME=admin
          MONGO_INITDB_ROOT_PASSWORD=mongodb123
          POSTGRES_USER=postgres
          POSTGRES_PASSWORD=postgres123
          POSTGRES_DB=acompanamiento
          REDIS_PASSWORD=redis123
          
          # Environment
          ENVIRONMENT=production
          ENV_CONTENT
          
          echo "âœ… .env file created"
          ENV_EOF

      # 6.5 Check and Clean Old Containers
      - name: ğŸ§¹ Check and Clean Old Containers
          echo 'Removing old MongoDB volume to force fresh start...'
          docker volume rm mongo_data_8686 2>/dev/null || true
        run: |
          echo "ğŸ” Checking for existing containers..."
          ssh -i ~/.ssh/aws-key.pem \
            -o StrictHostKeyChecking=no \
            ${{ env.SSH_USER }}@${{ env.EC2_DB_PUBLIC_IP }} << 'CLEAN_EOF'
          
          cd /opt/databases
          
          echo "ğŸ“Š Current containers:"
          docker ps -a --format "table {{.Names}}\t{{.Status}}" || echo "No containers found"
          
          echo ""
          echo "ğŸ§¹ Stopping all containers..."
          docker-compose down -v 2>/dev/null || true
          
          echo ""
          echo "ğŸ—‘ï¸  Removing all databases volumes..."
          docker volume rm -f $(docker volume ls -q --filter name=databases) 2>/dev/null || echo "No volumes to remove"
          
          echo ""
          echo "ğŸ§¹ Force removing old containers if any..."
          docker rm -f postgresql mongodb redis 2>/dev/null || echo "No containers to force remove"
          
          echo ""
          echo "ğŸ“Š Cleaned containers status:"
          docker ps -a || echo "No containers running"
          
          echo "âœ… Cleanup completed"
          CLEAN_EOF

      # 7. Start Docker Containers
      - name: ğŸš€ Start Database Containers
        run: |
          echo "ğŸš€ Starting Docker containers..."
          ssh -i ~/.ssh/aws-key.pem \
            -o StrictHostKeyChecking=no \
            ${{ env.SSH_USER }}@${{ env.EC2_DB_PUBLIC_IP }} << 'START_EOF'
          
          cd /opt/databases
          
          echo "ğŸ“¦ Starting containers with docker-compose..."
          docker-compose up -d
          
          echo "â³ Waiting 30 seconds for services to initialize..."
          sleep 30
          
          echo "ğŸ“Š Container Status:"
          docker ps -a --format "table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}"
          
          echo ""
          echo "âœ… All containers started"
          START_EOF

      # 8. Validate Databases
      - name: âœ… Validate Database Deployments
        run: |
          echo "ğŸ” Validating databases..."
          ssh -i ~/.ssh/aws-key.pem \
            -o StrictHostKeyChecking=no \
            ${{ env.SSH_USER }}@${{ env.EC2_DB_PUBLIC_IP }} << 'VALIDATE_EOF'
          
          cd /opt/databases
          
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ” COMPREHENSIVE DATABASE VALIDATION"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          
          # 1. Check MongoDB
          echo "1ï¸âƒ£  MongoDB Health Check"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          if docker exec mongodb mongosh --version > /dev/null 2>&1; then
            echo "âœ… MongoDB container is running"
            
            # Test MongoDB connection
            if docker exec mongodb mongosh --eval "db.adminCommand('ping')" --quiet > /dev/null 2>&1; then
              echo "âœ… MongoDB is responding to ping"
            else
              echo "âŒ MongoDB ping failed"
            fi
            
            # Show MongoDB logs
            echo ""
            echo "ğŸ“‹ MongoDB logs (last 5 lines):"
            docker logs mongodb | tail -5
          else
            echo "âŒ MongoDB container is not running"
            docker logs mongodb || echo "No logs available"
          fi
          
          echo ""
          echo "2ï¸âƒ£  PostgreSQL Health Check"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          if docker exec postgresql pg_isready -U postgres > /dev/null 2>&1; then
            echo "âœ… PostgreSQL is running and responding"
            
            # Check database
            if docker exec postgresql psql -U postgres -d acompanamiento -c "SELECT version();" > /dev/null 2>&1; then
              echo "âœ… PostgreSQL database 'acompanamiento' is accessible"
              docker exec postgresql psql -U postgres -d acompanamiento -c "SELECT version();" | head -1
            else
              echo "âŒ PostgreSQL database 'acompanamiento' is not accessible"
            fi
            
            # Show PostgreSQL logs
            echo ""
            echo "ğŸ“‹ PostgreSQL logs (last 5 lines):"
            docker logs postgresql | tail -5
          else
            echo "âŒ PostgreSQL container is not running or not responding"
            docker logs postgresql || echo "No logs available"
          fi
          
          echo ""
          echo "3ï¸âƒ£  Redis Health Check"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          if docker exec redis redis-cli -a redis123 ping > /dev/null 2>&1; then
            echo "âœ… Redis is running and responding"
            
            # Check Redis version
            REDIS_VERSION=$(docker exec redis redis-cli -a redis123 INFO server | grep redis_version | cut -d: -f2 | tr -d '\r')
            echo "   Redis version: $REDIS_VERSION"
            
            # Show Redis logs
            echo ""
            echo "ğŸ“‹ Redis logs (last 5 lines):"
            docker logs redis | tail -5
          else
            echo "âŒ Redis is not responding"
            docker logs redis || echo "No logs available"
          fi
          
          echo ""
          echo "4ï¸âƒ£  Network and Port Check"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo "ğŸ“ MongoDB port (27017):"
          netstat -tlnp 2>/dev/null | grep 27017 || echo "   âš ï¸  netstat not available, checking via docker"
          docker port mongodb 2>/dev/null | grep 27017 || echo "   âš ï¸  Port mapping not visible"
          
          echo "ğŸ“ PostgreSQL port (5432):"
          netstat -tlnp 2>/dev/null | grep 5432 || echo "   âš ï¸  netstat not available, checking via docker"
          docker port postgresql 2>/dev/null | grep 5432 || echo "   âš ï¸  Port mapping not visible"
          
          echo "ğŸ“ Redis port (6379):"
          netstat -tlnp 2>/dev/null | grep 6379 || echo "   âš ï¸  netstat not available, checking via docker"
          docker port redis 2>/dev/null | grep 6379 || echo "   âš ï¸  Port mapping not visible"
          
          echo ""
          echo "5ï¸âƒ£  Docker Volumes Check"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo "Available volumes:"
          docker volume ls --filter name=databases
          
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ“Š FINAL CONTAINER STATUS"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          docker ps -a --format "table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}"
          
          echo ""
          echo "âœ… Validation completed successfully!"
          VALIDATE_EOF

      # 9. Display Connection Information
      - name: ğŸ“‹ Display Connection Information
        run: |
          cat << 'INFO_EOF'
          
          â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
          â•‘             âœ… EC2-DB DEPLOYMENT COMPLETED                â•‘
          â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          
          ğŸŒ Instance Information:
            â€¢ Instance Name: EC2-DB
            â€¢ Public IP: ${{ env.EC2_DB_PUBLIC_IP }}
            â€¢ Private IP: ${{ env.EC2_DB_PRIVATE_IP }}
            â€¢ Region: ${{ env.AWS_REGION }}
          
          ğŸ’¾ Database Connection Strings (Internal VPC):
          
            MongoDB:
              URL: mongodb://admin:mongodb123@${{ env.EC2_DB_PRIVATE_IP }}:27017/acompanamiento?authSource=admin
              Port: 27017
          
            PostgreSQL:
              URL: postgresql://postgres:postgres123@${{ env.EC2_DB_PRIVATE_IP }}:5432/acompanamiento
              Port: 5432
          
            Redis:
              URL: redis://:redis123@${{ env.EC2_DB_PRIVATE_IP }}:6379
              Port: 6379
          
          âš ï¸  IMPORTANT:
            â€¢ Databases are NOT accessible from the internet
            â€¢ Only accessible from other EC2 instances in the VPC
            â€¢ Connection strings use PRIVATE IP (172.31.79.193)
          
          ğŸ” Default Credentials (CHANGE IN PRODUCTION):
            â€¢ MongoDB User: admin / Password: mongodb123
            â€¢ PostgreSQL User: postgres / Password: postgres123
            â€¢ Redis Password: redis123
          
          ğŸ“Š Verify Containers:
            SSH to instance and run: docker ps -a
          
          ğŸš€ Next Step: Deploy EC2-CORE
          
          INFO_EOF

      # 10. Commit and push (optional)
      - name: ğŸ“ Update Repository (Optional)
        if: github.event.inputs.environment == 'production'
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          echo "EC2-DB deployed at $(date)" >> DEPLOYMENT_LOG.md
          
          git add DEPLOYMENT_LOG.md || true
          git commit -m "docs: EC2-DB deployment completed at $(date)" || true
          git push || true
        continue-on-error: true

  # Notification Job
  notify:
    name: Send Deployment Notification
    needs: deploy-ec2-db
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: ğŸ“¢ Deployment Status
        run: |
          if [ "${{ needs.deploy-ec2-db.result }}" == "success" ]; then
            echo "âœ… EC2-DB deployment SUCCEEDED"
            exit 0
          else
            echo "âŒ EC2-DB deployment FAILED"
            exit 1
          fi
