name: Deploy to EC2

on:
  workflow_dispatch:
    inputs:
      rebuild_docker:
        description: 'Rebuild Docker images'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      environment:
        description: 'Environment'
        required: true
        default: 'prod'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  AWS_REGION: us-east-1
  DOCKER_BUILDKIT: 1

jobs:
  deploy-all-instances:
    name: Deploy All Instances
    runs-on: ubuntu-latest
    strategy:
      matrix:
        instance:
          - EC2_BASTION
          - EC2_CORE
          - EC2_DB
          - EC2_API_GATEWAY
          - EC2_FRONTEND
          - EC2_MESSAGING
          - EC2_MONITORING
          - EC2_REPORTES
          - EC2_NOTIFICACIONES
          - EC2_ANALYTICS
      max-parallel: 1
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN || '' }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Get EC2 IPs
        id: get-ip
        run: |
          INSTANCE="${{ matrix.instance }}"
          
          case "$INSTANCE" in
            EC2_BASTION)
              TAG_NAME="EC-Bastion"
              ;;
            EC2_CORE)
              TAG_NAME="EC2-CORE"
              ;;
            EC2_DB)
              TAG_NAME="EC2-DB"
              ;;
            EC2_API_GATEWAY)
              TAG_NAME="EC2-API-Gateway"
              ;;
            EC2_FRONTEND)
              TAG_NAME="EC2-Frontend"
              ;;
            EC2_MESSAGING)
              TAG_NAME="EC2-Messaging"
              ;;
            EC2_MONITORING)
              TAG_NAME="EC2-Monitoring"
              ;;
            EC2_REPORTES)
              TAG_NAME="EC2-Reportes"
              ;;
            EC2_NOTIFICACIONES)
              TAG_NAME="EC2-Notificaciones"
              ;;
            EC2_ANALYTICS)
              TAG_NAME="EC2-Analytics"
              ;;
            *)
              echo "Unknown instance: $INSTANCE"
              exit 1
              ;;
          esac
          
          INSTANCE_DATA=$(aws ec2 describe-instances \
            --region $AWS_REGION \
            --filters "Name=instance-state-name,Values=running" "Name=tag:Name,Values=$TAG_NAME" \
            --query 'Reservations[0].Instances[0]' \
            --output json)
          
          if [ "$INSTANCE_DATA" = "null" ] || [ -z "$INSTANCE_DATA" ]; then
            echo "ERROR: No running instance found with tag Name=$TAG_NAME"
            exit 1
          fi
          
          PUBLIC_IP=$(echo "$INSTANCE_DATA" | jq -r '.PublicIpAddress')
          PRIVATE_IP=$(echo "$INSTANCE_DATA" | jq -r '.PrivateIpAddress')
          INSTANCE_ID=$(echo "$INSTANCE_DATA" | jq -r '.InstanceId')
          INSTANCE_NAME=$(echo "$INSTANCE_DATA" | jq -r '.Tags[] | select(.Key=="Name") | .Value' | head -1)
          
          echo "public_ip=$PUBLIC_IP" >> $GITHUB_OUTPUT
          echo "private_ip=$PRIVATE_IP" >> $GITHUB_OUTPUT
          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "instance_name=$INSTANCE_NAME" >> $GITHUB_OUTPUT
          
          echo "âœ… Encontrada: $INSTANCE_NAME"
          echo "   IP PÃºblica: $PUBLIC_IP"
          echo "   IP Privada: $PRIVATE_IP"
      
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ steps.get-ip.outputs.public_ip }} >> ~/.ssh/known_hosts 2>/dev/null || true
      
      - name: Deploy to EC2 Instance
        env:
          PUBLIC_IP: ${{ steps.get-ip.outputs.public_ip }}
          INSTANCE: ${{ matrix.instance }}
          GITHUB_REPO: ${{ github.repository }}
          GITHUB_REF: ${{ github.ref }}
        timeout-minutes: 45
        run: |
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o ConnectTimeout=30 -o ServerAliveInterval=60 ubuntu@$PUBLIC_IP bash -s "$INSTANCE" "$GITHUB_REPO" "$GITHUB_REF" << DEPLOYSCRIPT
          INSTANCE="$1"
          GITHUB_REPO="$2"
          GITHUB_REF="$3"
          
          echo "================================================"
          echo "ðŸš€ Desplegando: $INSTANCE"
          echo "================================================"
          set -e
          
          # 1. Clone repository
          echo "ðŸ“¥ Clonando repositorio..."
          cd ~
          rm -rf app-build 2>/dev/null || true
          # Verificar si git estÃ¡ disponible
          if ! command -v git &> /dev/null; then
            echo "âš ï¸  Git no encontrado, instalando..."
            sudo apt-get update -qq && sudo apt-get install -y -qq git > /dev/null 2>&1 || true
          fi
          git clone --depth 1 https://github.com/${GITHUB_REPO}.git app-build
          cd app-build
          git checkout ${GITHUB_REF#refs/heads/}
          echo "âœ… Repositorio clonado"
          
          # 2. Clean Docker
          echo "ðŸ§¹ Limpiando Docker..."
          docker system prune -af --volumes 2>/dev/null || true
          mkdir -p ~/docker-images ~/app
          
          # 3. Determine docker-compose file
          COMPOSE_FILE=""
          case "$INSTANCE" in
            EC2_BASTION)
              COMPOSE_FILE="docker-compose.ec2-bastion.yml"
              ;;
            EC2_CORE)
              COMPOSE_FILE="docker-compose.ec2-core.yml"
              ;;
            EC2_API_GATEWAY)
              COMPOSE_FILE="docker-compose.api-gateway.yml"
              ;;
            EC2_FRONTEND)
              COMPOSE_FILE="docker-compose.ec2-frontend.yml"
              ;;
            EC2_MESSAGING)
              COMPOSE_FILE="docker-compose.ec2-messaging.yml"
              ;;
            EC2_MONITORING)
              COMPOSE_FILE="docker-compose.ec2-monitoring.yml"
              ;;
            EC2_DB)
              COMPOSE_FILE="docker-compose.ec2-db.yml"
              ;;
            EC2_REPORTES)
              COMPOSE_FILE="docker-compose.ec2-reportes.yml"
              ;;
            EC2_NOTIFICACIONES)
              COMPOSE_FILE="docker-compose.ec2-notificaciones.yml"
              ;;
            EC2_ANALYTICS)
              COMPOSE_FILE="docker-compose.ec2-analytics.yml"
              ;;
          esac
          
          # 4. Build Docker images
          echo "ðŸ—ï¸  Compilando imÃ¡genes Docker..."
          case "$INSTANCE" in
            EC2_BASTION)
              echo "   â†’ Compilando bastion-host..."
              cd bastion-host && docker build -t bastion-host:latest . && cd ..
              ;;
            EC2_CORE)
              for SERVICE in micro-auth micro-estudiantes micro-maestros micro-core; do
                if [ -f "./$SERVICE/Dockerfile" ]; then
                  echo "   â†’ Compilando $SERVICE..."
                  docker build -t $SERVICE:latest -f ./$SERVICE/Dockerfile .
                fi
              done
              ;;
            EC2_API_GATEWAY)
              if [ -f "./api-gateway/Dockerfile" ]; then
                echo "   â†’ Compilando api-gateway..."
                docker build -t api-gateway:latest -f ./api-gateway/Dockerfile .
              fi
              ;;
            EC2_REPORTES)
              for SERVICE in micro-reportes-estudiantes micro-reportes-maestros; do
                if [ -f "./$SERVICE/Dockerfile" ]; then
                  echo "   â†’ Compilando $SERVICE..."
                  docker build -t $SERVICE:latest -f ./$SERVICE/Dockerfile .
                fi
              done
              ;;
            EC2_NOTIFICACIONES)
              if [ -f "./micro-notificaciones/Dockerfile" ]; then
                echo "   â†’ Compilando micro-notificaciones..."
                docker build -t micro-notificaciones:latest -f ./micro-notificaciones/Dockerfile .
              fi
              ;;
            EC2_ANALYTICS)
              if [ -f "./micro-analytics/Dockerfile" ]; then
                echo "   â†’ Compilando micro-analytics..."
                docker build -t micro-analytics:latest -f ./micro-analytics/Dockerfile .
              fi
              ;;
            EC2_FRONTEND)
              if [ -f "./frontend-web/Dockerfile" ]; then
                echo "   â†’ Compilando frontend-web..."
                docker build -t frontend-web:latest -f ./frontend-web/Dockerfile ./frontend-web
              fi
              ;;
            EC2_MESSAGING|EC2_MONITORING|EC2_DB)
              echo "   â„¹ï¸  Usando imÃ¡genes pre-construidas de Docker Hub"
              ;;
          esac
          echo "âœ… ImÃ¡genes compiladas"
          
          # 5. Start services with docker-compose
          # Try to find the compose file in the current directory or in app-build (in case of path issues)
          if [ -f "$COMPOSE_FILE" ]; then
            cp "$COMPOSE_FILE" ~/app/docker-compose.yml
          elif [ -f "app-build/$COMPOSE_FILE" ]; then
            cp "app-build/$COMPOSE_FILE" ~/app/docker-compose.yml
          else
            echo "âŒ ERROR: No se encontrÃ³ el archivo de docker-compose requerido: $COMPOSE_FILE"
            echo "Directorio actual: $(pwd)"
            echo "Archivos en el directorio actual:"
            ls -l
            echo "Archivos en app-build:"
            ls -l app-build || true
            echo "NOTA: Los scripts de verificaciÃ³n y actualizaciÃ³n listados no afectan el despliegue. Solo se requiere el archivo docker-compose correspondiente."
            exit 1
          fi
          echo ""
          echo "ðŸš€ Iniciando servicios..."
          cd ~/app
          docker-compose down 2>/dev/null || true
          sleep 2
          docker-compose up -d
          sleep 15
          echo ""
          echo "ðŸ“Š Estado de servicios:"
          docker-compose ps
          echo ""
          echo "================================================"
          echo "âœ… DESPLIEGUE COMPLETADO: $INSTANCE"
          echo "================================================"
          
          DEPLOYSCRIPT
      
      - name: Verify Deployment
        if: always()
        continue-on-error: true
        env:
          PUBLIC_IP: ${{ steps.get-ip.outputs.public_ip }}
        run: |
          echo "âœ… Verificando despliegue de ${{ matrix.instance }}..."
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o ConnectTimeout=30 ubuntu@$PUBLIC_IP bash << VERIFYSCRIPT
          cd ~/app
          echo "ðŸ“‹ Estado de servicios:"
          docker-compose ps
          echo ""
          echo "ðŸ“ Ãšltimos logs (20 lÃ­neas):"
          docker-compose logs --tail=20 2>&1 || true
          VERIFYSCRIPT
