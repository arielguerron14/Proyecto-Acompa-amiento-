name: üöÄ Deploy Everything (Complete Architecture)

on:
  workflow_dispatch:
    inputs:
      rebuild_images:
        description: 'Rebuild images from source if missing'
        required: true
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

concurrency:
  group: deployment
  cancel-in-progress: false

env:
  AWS_REGION: us-east-1
  DOCKER_REGISTRY: docker.io

jobs:
  # ===========================================================================
  # COMPLETE DEPLOYMENT - ALL 10 HOSTS, 20+ SERVICES IN CORRECT ORDER
  # ===========================================================================
  deploy-infrastructure:
    name: üöÄ Deploy Complete Infrastructure
    runs-on: ubuntu-latest
    timeout-minutes: 120

    steps:
      # =========================================================================
      # STEP 1: PREPARE
      # =========================================================================
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install dependencies
        run: |
          pip install paramiko requests pyyaml boto3
          echo "‚úÖ Dependencies installed"

      - name: Load configuration
        id: config
        run: |
          python3 << 'PYTHON'
          import json
          
          with open('config/instance_ips.json', 'r') as f:
              config = json.load(f)
          
          # Extract all IPs in order
          hosts = {
              'messaging': config['EC2-Messaging'],
              'db': config['EC2-DB'],
              'core': config['EC2-CORE'],
              'api': config['EC2-API-Gateway'],
              'analytics': config.get('EC2-Analytics', config['EC2-DB']),  # fallback to DB if not separate
              'reportes': config['EC2-Reportes'],
              'notificaciones': config['EC2-Notificaciones'],
              'monitoring': config['EC2-Monitoring'],
              'frontend': config['EC2-Frontend'],
              'bastion': config['EC-Bastion']
          }
          
          # Set outputs
          for host_type, host_data in hosts.items():
              print(f"::set-output name={host_type}_public::{host_data['PublicIpAddress']}")
              print(f"::set-output name={host_type}_private::{host_data['PrivateIpAddress']}")
          
          print("\n‚úÖ All 10 hosts loaded:")
          for host_type, host_data in hosts.items():
              print(f"   {host_type}: {host_data['PublicIpAddress']}")
          PYTHON

      # =========================================================================
      # STEP 2: DEPLOY EC2-MESSAGING (Zookeeper, Kafka, RabbitMQ)
      # =========================================================================
      - name: "‚è±Ô∏è  1/10: Deploy Messaging Queue Infrastructure"
        env:
          TARGET_HOST: ${{ steps.config.outputs.messaging_public }}
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
          REBUILD: ${{ github.event.inputs.rebuild_images }}
        run: |
          python3 << 'PYTHON'
          import paramiko
          import io
          import os
          import time
          
          target = os.environ['TARGET_HOST']
          ssh_key = os.environ['EC2_SSH_KEY']
          
          print(f"\n{'='*70}")
          print(f"‚è±Ô∏è  STEP 1/10: Deploy Messaging (Zookeeper, Kafka, RabbitMQ)")
          print(f"{'='*70}\n")
          
          ssh = paramiko.SSHClient()
          ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
          
          for attempt in range(3):
              try:
                  print(f"üîó Connection attempt {attempt + 1}/3...")
                  key = paramiko.RSAKey.from_private_key(io.StringIO(ssh_key))
                  ssh.connect(target, username='ubuntu', pkey=key, timeout=15)
                  print("‚úÖ Connected to EC2-Messaging\n")
                  break
              except Exception as e:
                  if attempt < 2:
                      print(f"‚ö†Ô∏è  Failed: {str(e)[:50]}, retrying in 10s...")
                      time.sleep(10)
                  else:
                      print(f"‚ùå Failed: {e}")
                      exit(1)
          
          commands = [
              ("Create messaging network", "docker network create msg-net 2>/dev/null || true"),
              ("Stop old services", "docker stop zookeeper kafka rabbitmq 2>/dev/null || true"),
              ("Remove old services", "docker rm zookeeper kafka rabbitmq 2>/dev/null || true"),
              ("Pull Zookeeper", "docker pull proyectozookeeper/zookeeper:1.0 2>/dev/null || docker pull confluentinc/cp-zookeeper:7.0.0"),
              ("Pull Kafka", "docker pull proyectokafka/kafka:1.0 2>/dev/null || docker pull confluentinc/cp-kafka:7.0.0"),
              ("Pull RabbitMQ", "docker pull proyectorabbitmq/rabbitmq:1.0 2>/dev/null || docker pull rabbitmq:3.12-management"),
              ("Start Zookeeper", """docker run -d --name zookeeper --network msg-net -p 2181:2181 -e ZOO_CFG_SERVER_1=zookeeper:2888:3888 proyectozookeeper/zookeeper:1.0 2>/dev/null || docker run -d --name zookeeper --network msg-net -p 2181:2181 confluentinc/cp-zookeeper:7.0.0 -e ZOOKEEPER_CLIENT_PORT=2181"""),
              ("Wait for Zookeeper", "sleep 5"),
              ("Start Kafka", """docker run -d --name kafka --network msg-net -p 9092:9092 -e KAFKA_BROKER_ID=1 -e KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://kafka:9092 proyectokafka/kafka:1.0 2>/dev/null || docker run -d --name kafka --network msg-net -p 9092:9092 confluentinc/cp-kafka:7.0.0 -e KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181"""),
              ("Wait for Kafka", "sleep 5"),
              ("Start RabbitMQ", "docker run -d --name rabbitmq --network msg-net -p 5672:5672 -p 15672:15672 -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin proyectorabbitmq/rabbitmq:1.0 2>/dev/null || docker run -d --name rabbitmq --network msg-net -p 5672:5672 -p 15672:15672 -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin rabbitmq:3.12-management"),
              ("Wait for RabbitMQ", "sleep 10"),
              ("Verify services", "docker ps -a -f 'name=zookeeper|kafka|rabbitmq' --format='table {{.Names}}\\t{{.Status}}'"),
          ]
          
          for desc, cmd in commands:
              print(f"  ‚ñ∂Ô∏è  {desc}...")
              stdin, stdout, stderr = ssh.exec_command(cmd)
              output = stdout.read().decode().strip()
              if output and 'table' not in cmd:
                  for line in output.split('\n')[-2:]:
                      print(f"     {line}")
              time.sleep(1)
          
          print("\n‚úÖ Messaging deployment complete!\n")
          ssh.close()
          PYTHON

      # =========================================================================
      # STEP 3: DEPLOY EC2-DB (MongoDB, PostgreSQL, Redis)
      # =========================================================================
      - name: "üóÑÔ∏è  2/10: Deploy Database Services"
        env:
          TARGET_HOST: ${{ steps.config.outputs.db_public }}
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
        run: |
          python3 << 'PYTHON'
          import paramiko
          import io
          import os
          import time
          
          target = os.environ['TARGET_HOST']
          ssh_key = os.environ['EC2_SSH_KEY']
          
          print(f"\n{'='*70}")
          print(f"üóÑÔ∏è  STEP 2/10: Deploy Databases (MongoDB, PostgreSQL, Redis)")
          print(f"{'='*70}\n")
          
          ssh = paramiko.SSHClient()
          ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
          
          for attempt in range(3):
              try:
                  print(f"üîó Connection attempt {attempt + 1}/3...")
                  key = paramiko.RSAKey.from_private_key(io.StringIO(ssh_key))
                  ssh.connect(target, username='ubuntu', pkey=key, timeout=15)
                  print("‚úÖ Connected to EC2-DB\n")
                  break
              except Exception as e:
                  if attempt < 2:
                      print(f"‚ö†Ô∏è  Failed, retrying...")
                      time.sleep(10)
                  else:
                      print(f"‚ùå Failed: {e}")
                      exit(1)
          
          commands = [
              ("Stop old databases", "docker stop mongo postgres redis 2>/dev/null || true"),
              ("Remove old databases", "docker rm mongo postgres redis 2>/dev/null || true"),
              ("Create volumes", "docker volume create mongo_data postgres_data redis_data 2>/dev/null || true"),
              ("Pull MongoDB", "docker pull mongo:latest"),
              ("Pull PostgreSQL", "docker pull postgres:latest"),
              ("Pull Redis", "docker pull redis:latest"),
              ("Start MongoDB", """docker run -d --name mongo -p 27017:27017 \\
                -e MONGO_INITDB_ROOT_USERNAME=root \\
                -e MONGO_INITDB_ROOT_PASSWORD=example \\
                -v mongo_data:/data/db \\
                mongo:latest --auth --bind_ip_all"""),
              ("Start PostgreSQL", """docker run -d --name postgres -p 5432:5432 \\
                -e POSTGRES_USER=admin \\
                -e POSTGRES_PASSWORD=admin123 \\
                -e POSTGRES_DB=proyecto \\
                -v postgres_data:/var/lib/postgresql/data \\
                postgres:latest"""),
              ("Start Redis", """docker run -d --name redis -p 6379:6379 \\
                -v redis_data:/data \\
                redis:latest redis-server --appendonly yes"""),
              ("Wait for databases", "sleep 15"),
              ("Verify databases", "docker ps -a -f 'name=mongo|postgres|redis' --format='table {{.Names}}\\t{{.Status}}'"),
          ]
          
          for desc, cmd in commands:
              print(f"  ‚ñ∂Ô∏è  {desc}...")
              stdin, stdout, stderr = ssh.exec_command(cmd)
              output = stdout.read().decode().strip()
              if output and 'table' not in cmd:
                  for line in output.split('\n')[-2:]:
                      if line.strip():
                          print(f"     {line}")
              time.sleep(1)
          
          print("\n‚úÖ Database deployment complete!\n")
          ssh.close()
          PYTHON

      # =========================================================================
      # STEP 4: DEPLOY EC2-CORE (4 Microservices)
      # =========================================================================
      - name: "üê≥ 3/10: Deploy Core Microservices"
        env:
          TARGET_HOST: ${{ steps.config.outputs.core_public }}
          DB_PRIVATE_IP: ${{ steps.config.outputs.db_private }}
          DOCKER_USER: ${{ secrets.DOCKER_USERNAME }}
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
        run: |
          python3 << 'PYTHON'
          import paramiko
          import io
          import os
          import time
          
          target = os.environ['TARGET_HOST']
          db_ip = os.environ['DB_PRIVATE_IP']
          docker_user = os.environ['DOCKER_USER']
          ssh_key = os.environ['EC2_SSH_KEY']
          
          print(f"\n{'='*70}")
          print(f"üê≥ STEP 3/10: Deploy Core Microservices (4 services)")
          print(f"{'='*70}\n")
          print(f"   Database IP: {db_ip}\n")
          
          ssh = paramiko.SSHClient()
          ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
          
          for attempt in range(3):
              try:
                  print(f"üîó Connection attempt {attempt + 1}/3...")
                  key = paramiko.RSAKey.from_private_key(io.StringIO(ssh_key))
                  ssh.connect(target, username='ubuntu', pkey=key, timeout=15)
                  print("‚úÖ Connected to EC2-CORE\n")
                  break
              except Exception as e:
                  if attempt < 2:
                      print(f"‚ö†Ô∏è  Failed, retrying...")
                      time.sleep(10)
                  else:
                      print(f"‚ùå Failed: {e}")
                      exit(1)
          
          commands = [
              ("Create network", "docker network create core-net 2>/dev/null || true"),
              ("Stop old services", "docker stop micro-auth micro-estudiantes micro-maestros micro-core 2>/dev/null || true"),
              ("Remove old services", "docker rm micro-auth micro-estudiantes micro-maestros micro-core 2>/dev/null || true"),
          ]
          
          for desc, cmd in commands:
              print(f"  ‚ñ∂Ô∏è  {desc}...")
              ssh.exec_command(cmd)
              time.sleep(1)
          
          services = [
              ("micro-auth", "3000", "auth"),
              ("micro-estudiantes", "3001", "estudiantes"),
              ("micro-maestros", "3002", "maestros"),
              ("micro-core", "3003", "core"),
          ]
          
          print(f"\n  ‚ñ∂Ô∏è  Deploy 4 microservices...")
          for service, port, db_name in services:
              print(f"     ‚Ä¢ {service} on port {port}...")
              ssh.exec_command(f"docker pull {docker_user}/{service}:latest 2>/dev/null")
              time.sleep(2)
              
              cmd = f"""docker run -d --name {service} --network core-net -p {port}:{port} \\
                -e MONGODB_URI='mongodb://root:example@{db_ip}:27017/{db_name}?authSource=admin' \\
                -e PORT={port} -e NODE_ENV=production \\
                {docker_user}/{service}:latest"""
              ssh.exec_command(cmd)
              time.sleep(2)
          
          print(f"\n  ‚ñ∂Ô∏è  Verify microservices...")
          time.sleep(5)
          ssh.exec_command("docker ps -a -f 'name=micro-' --format='table {{.Names}}\\t{{.Status}}'")
          
          print("\n‚úÖ Core microservices deployment complete!\n")
          ssh.close()
          PYTHON

      # =========================================================================
      # STEP 5: DEPLOY EC2-API-GATEWAY
      # =========================================================================
      - name: "üåê 4/10: Deploy API Gateway"
        env:
          TARGET_HOST: ${{ steps.config.outputs.api_public }}
          CORE_PRIVATE_IP: ${{ steps.config.outputs.core_private }}
          DOCKER_USER: ${{ secrets.DOCKER_USERNAME }}
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
        run: |
          python3 << 'PYTHON'
          import paramiko
          import io
          import os
          import time
          
          target = os.environ['TARGET_HOST']
          core_ip = os.environ['CORE_PRIVATE_IP']
          docker_user = os.environ['DOCKER_USER']
          ssh_key = os.environ['EC2_SSH_KEY']
          
          print(f"\n{'='*70}")
          print(f"üåê STEP 4/10: Deploy API Gateway")
          print(f"{'='*70}\n")
          
          ssh = paramiko.SSHClient()
          ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
          
          for attempt in range(3):
              try:
                  print(f"üîó Connection attempt {attempt + 1}/3...")
                  key = paramiko.RSAKey.from_private_key(io.StringIO(ssh_key))
                  ssh.connect(target, username='ubuntu', pkey=key, timeout=15)
                  print("‚úÖ Connected to EC2-API-Gateway\n")
                  break
              except Exception as e:
                  if attempt < 2:
                      print(f"‚ö†Ô∏è  Failed, retrying...")
                      time.sleep(10)
                  else:
                      print(f"‚ùå Failed: {e}")
                      exit(1)
          
          commands = [
              ("Stop old API", "docker stop api-gateway 2>/dev/null || true"),
              ("Remove old API", "docker rm api-gateway 2>/dev/null || true"),
              ("Pull image", f"docker pull {docker_user}/api-gateway:latest"),
              ("Start API Gateway", f"""docker run -d --name api-gateway -p 8080:8080 \\
                -e CORE_HOST={core_ip} -e NODE_ENV=production \\
                {docker_user}/api-gateway:latest"""),
              ("Wait", "sleep 10"),
              ("Verify", "docker ps -a -f name=api-gateway --format='table {{.Names}}\\t{{.Status}}'"),
          ]
          
          for desc, cmd in commands:
              print(f"  ‚ñ∂Ô∏è  {desc}...")
              ssh.exec_command(cmd)
              time.sleep(1)
          
          print("\n‚úÖ API Gateway deployment complete!\n")
          ssh.close()
          PYTHON

      # =========================================================================
      # STEP 6: DEPLOY EC2-ANALYTICS
      # =========================================================================
      - name: "üìä 5/10: Deploy Analytics"
        env:
          TARGET_HOST: ${{ steps.config.outputs.analytics_public }}
          DB_PRIVATE_IP: ${{ steps.config.outputs.db_private }}
          DOCKER_USER: ${{ secrets.DOCKER_USERNAME }}
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
        run: |
          python3 << 'PYTHON'
          import paramiko
          import io
          import os
          import time
          
          target = os.environ['TARGET_HOST']
          db_ip = os.environ['DB_PRIVATE_IP']
          docker_user = os.environ['DOCKER_USER']
          ssh_key = os.environ['EC2_SSH_KEY']
          
          print(f"\n{'='*70}")
          print(f"üìä STEP 5/10: Deploy Analytics")
          print(f"{'='*70}\n")
          
          ssh = paramiko.SSHClient()
          ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
          
          for attempt in range(3):
              try:
                  print(f"üîó Connection attempt {attempt + 1}/3...")
                  key = paramiko.RSAKey.from_private_key(io.StringIO(ssh_key))
                  ssh.connect(target, username='ubuntu', pkey=key, timeout=15)
                  print("‚úÖ Connected to EC2-Analytics\n")
                  break
              except Exception as e:
                  if attempt < 2:
                      print(f"‚ö†Ô∏è  Failed, retrying...")
                      time.sleep(10)
                  else:
                      print(f"‚ùå Failed: {e}")
                      exit(1)
          
          commands = [
              ("Stop old service", "docker stop micro-analytics 2>/dev/null || true"),
              ("Remove old service", "docker rm micro-analytics 2>/dev/null || true"),
              ("Pull image", f"docker pull {docker_user}/micro-analytics:latest"),
              ("Start Analytics", f"""docker run -d --name micro-analytics -p 3004:3004 \\
                -e MONGODB_URI='mongodb://root:example@{db_ip}:27017/analytics?authSource=admin' \\
                -e PORT=3004 \\
                {docker_user}/micro-analytics:latest"""),
              ("Wait", "sleep 5"),
              ("Verify", "docker ps -a -f name=micro-analytics --format='table {{.Names}}\\t{{.Status}}'"),
          ]
          
          for desc, cmd in commands:
              print(f"  ‚ñ∂Ô∏è  {desc}...")
              ssh.exec_command(cmd)
              time.sleep(1)
          
          print("\n‚úÖ Analytics deployment complete!\n")
          ssh.close()
          PYTHON

      # =========================================================================
      # STEP 7: DEPLOY EC2-REPORTES (2 Services)
      # =========================================================================
      - name: "üìÑ 6/10: Deploy Reports Services"
        env:
          TARGET_HOST: ${{ steps.config.outputs.reportes_public }}
          DB_PRIVATE_IP: ${{ steps.config.outputs.db_private }}
          DOCKER_USER: ${{ secrets.DOCKER_USERNAME }}
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
        run: |
          python3 << 'PYTHON'
          import paramiko
          import io
          import os
          import time
          
          target = os.environ['TARGET_HOST']
          db_ip = os.environ['DB_PRIVATE_IP']
          docker_user = os.environ['DOCKER_USER']
          ssh_key = os.environ['EC2_SSH_KEY']
          
          print(f"\n{'='*70}")
          print(f"üìÑ STEP 6/10: Deploy Reports (2 services)")
          print(f"{'='*70}\n")
          
          ssh = paramiko.SSHClient()
          ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
          
          for attempt in range(3):
              try:
                  print(f"üîó Connection attempt {attempt + 1}/3...")
                  key = paramiko.RSAKey.from_private_key(io.StringIO(ssh_key))
                  ssh.connect(target, username='ubuntu', pkey=key, timeout=15)
                  print("‚úÖ Connected to EC2-Reportes\n")
                  break
              except Exception as e:
                  if attempt < 2:
                      print(f"‚ö†Ô∏è  Failed, retrying...")
                      time.sleep(10)
                  else:
                      print(f"‚ùå Failed: {e}")
                      exit(1)
          
          commands = [
              ("Stop old services", "docker stop micro-reportes-estudiantes micro-reportes-maestros 2>/dev/null || true"),
              ("Remove old services", "docker rm micro-reportes-estudiantes micro-reportes-maestros 2>/dev/null || true"),
          ]
          
          for desc, cmd in commands:
              print(f"  ‚ñ∂Ô∏è  {desc}...")
              ssh.exec_command(cmd)
              time.sleep(1)
          
          reports = [
              ("micro-reportes-estudiantes", "3005", "reportes_estudiantes"),
              ("micro-reportes-maestros", "3006", "reportes_maestros"),
          ]
          
          print(f"\n  ‚ñ∂Ô∏è  Deploy 2 report services...")
          for service, port, db_name in reports:
              print(f"     ‚Ä¢ {service}...")
              ssh.exec_command(f"docker pull {docker_user}/{service}:latest 2>/dev/null")
              time.sleep(2)
              
              cmd = f"""docker run -d --name {service} -p {port}:{port} \\
                -e MONGODB_URI='mongodb://root:example@{db_ip}:27017/{db_name}?authSource=admin' \\
                -e PORT={port} \\
                {docker_user}/{service}:latest"""
              ssh.exec_command(cmd)
              time.sleep(2)
          
          print("\n‚úÖ Reports deployment complete!\n")
          ssh.close()
          PYTHON

      # =========================================================================
      # STEP 8: DEPLOY EC2-NOTIFICACIONES
      # =========================================================================
      - name: "üîî 7/10: Deploy Notifications"
        env:
          TARGET_HOST: ${{ steps.config.outputs.notificaciones_public }}
          DB_PRIVATE_IP: ${{ steps.config.outputs.db_private }}
          MESSAGING_PRIVATE_IP: ${{ steps.config.outputs.messaging_private }}
          DOCKER_USER: ${{ secrets.DOCKER_USERNAME }}
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
        run: |
          python3 << 'PYTHON'
          import paramiko
          import io
          import os
          import time
          
          target = os.environ['TARGET_HOST']
          db_ip = os.environ['DB_PRIVATE_IP']
          msg_ip = os.environ['MESSAGING_PRIVATE_IP']
          docker_user = os.environ['DOCKER_USER']
          ssh_key = os.environ['EC2_SSH_KEY']
          
          print(f"\n{'='*70}")
          print(f"üîî STEP 7/10: Deploy Notifications")
          print(f"{'='*70}\n")
          
          ssh = paramiko.SSHClient()
          ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
          
          for attempt in range(3):
              try:
                  print(f"üîó Connection attempt {attempt + 1}/3...")
                  key = paramiko.RSAKey.from_private_key(io.StringIO(ssh_key))
                  ssh.connect(target, username='ubuntu', pkey=key, timeout=15)
                  print("‚úÖ Connected to EC2-Notificaciones\n")
                  break
              except Exception as e:
                  if attempt < 2:
                      print(f"‚ö†Ô∏è  Failed, retrying...")
                      time.sleep(10)
                  else:
                      print(f"‚ùå Failed: {e}")
                      exit(1)
          
          commands = [
              ("Stop old service", "docker stop micro-notificaciones 2>/dev/null || true"),
              ("Remove old service", "docker rm micro-notificaciones 2>/dev/null || true"),
              ("Pull image", f"docker pull {docker_user}/micro-notificaciones:latest"),
              ("Start Notifications", f"""docker run -d --name micro-notificaciones -p 3007:3007 \\
                -e MONGODB_URI='mongodb://root:example@{db_ip}:27017/notificaciones?authSource=admin' \\
                -e RABBITMQ_URL='amqp://admin:admin@{msg_ip}:5672' \\
                -e PORT=3007 \\
                {docker_user}/micro-notificaciones:latest"""),
              ("Wait", "sleep 5"),
              ("Verify", "docker ps -a -f name=micro-notificaciones --format='table {{.Names}}\\t{{.Status}}'"),
          ]
          
          for desc, cmd in commands:
              print(f"  ‚ñ∂Ô∏è  {desc}...")
              ssh.exec_command(cmd)
              time.sleep(1)
          
          print("\n‚úÖ Notifications deployment complete!\n")
          ssh.close()
          PYTHON

      # =========================================================================
      # STEP 9: DEPLOY EC2-MONITORING (Prometheus, Grafana)
      # =========================================================================
      - name: "üìà 8/10: Deploy Monitoring Stack"
        env:
          TARGET_HOST: ${{ steps.config.outputs.monitoring_public }}
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
        run: |
          python3 << 'PYTHON'
          import paramiko
          import io
          import os
          import time
          
          target = os.environ['TARGET_HOST']
          ssh_key = os.environ['EC2_SSH_KEY']
          
          print(f"\n{'='*70}")
          print(f"üìà STEP 8/10: Deploy Monitoring (Prometheus, Grafana)")
          print(f"{'='*70}\n")
          
          ssh = paramiko.SSHClient()
          ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
          
          for attempt in range(3):
              try:
                  print(f"üîó Connection attempt {attempt + 1}/3...")
                  key = paramiko.RSAKey.from_private_key(io.StringIO(ssh_key))
                  ssh.connect(target, username='ubuntu', pkey=key, timeout=15)
                  print("‚úÖ Connected to EC2-Monitoring\n")
                  break
              except Exception as e:
                  if attempt < 2:
                      print(f"‚ö†Ô∏è  Failed, retrying...")
                      time.sleep(10)
                  else:
                      print(f"‚ùå Failed: {e}")
                      exit(1)
          
          commands = [
              ("Create monitoring network", "docker network create monitoring 2>/dev/null || true"),
              ("Stop old services", "docker stop prometheus grafana 2>/dev/null || true"),
              ("Remove old services", "docker rm prometheus grafana 2>/dev/null || true"),
              ("Create volumes", "docker volume create prometheus_data grafana_data 2>/dev/null || true"),
              ("Pull Prometheus", "docker pull proyectoprometheus/prometheus:1.0 2>/dev/null || docker pull prom/prometheus:latest"),
              ("Pull Grafana", "docker pull proyectografana/grafana:1.0 2>/dev/null || docker pull grafana/grafana:latest"),
              ("Start Prometheus", """docker run -d --name prometheus --network monitoring -p 9090:9090 \\
                -v prometheus_data:/prometheus \\
                proyectoprometheus/prometheus:1.0 2>/dev/null || \\
                docker run -d --name prometheus --network monitoring -p 9090:9090 \\
                -v prometheus_data:/prometheus prom/prometheus:latest"""),
              ("Start Grafana", """docker run -d --name grafana --network monitoring -p 3000:3000 \\
                -e GF_SECURITY_ADMIN_PASSWORD=admin \\
                -v grafana_data:/var/lib/grafana \\
                proyectografana/grafana:1.0 2>/dev/null || \\
                docker run -d --name grafana --network monitoring -p 3000:3000 \\
                -e GF_SECURITY_ADMIN_PASSWORD=admin \\
                -v grafana_data:/var/lib/grafana grafana/grafana:latest"""),
              ("Wait", "sleep 10"),
              ("Verify", "docker ps -a -f 'name=prometheus|grafana' --format='table {{.Names}}\\t{{.Status}}'"),
          ]
          
          for desc, cmd in commands:
              print(f"  ‚ñ∂Ô∏è  {desc}...")
              ssh.exec_command(cmd)
              time.sleep(1)
          
          print("\n‚úÖ Monitoring deployment complete!\n")
          ssh.close()
          PYTHON

      # =========================================================================
      # STEP 10: DEPLOY EC2-FRONTEND
      # =========================================================================
      - name: "üé® 9/10: Deploy Frontend"
        env:
          TARGET_HOST: ${{ steps.config.outputs.frontend_public }}
          API_PRIVATE_IP: ${{ steps.config.outputs.api_private }}
          DOCKER_USER: ${{ secrets.DOCKER_USERNAME }}
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
        run: |
          python3 << 'PYTHON'
          import paramiko
          import io
          import os
          import time
          
          target = os.environ['TARGET_HOST']
          api_ip = os.environ['API_PRIVATE_IP']
          docker_user = os.environ['DOCKER_USER']
          ssh_key = os.environ['EC2_SSH_KEY']
          
          print(f"\n{'='*70}")
          print(f"üé® STEP 9/10: Deploy Frontend")
          print(f"{'='*70}\n")
          
          ssh = paramiko.SSHClient()
          ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
          
          for attempt in range(3):
              try:
                  print(f"üîó Connection attempt {attempt + 1}/3...")
                  key = paramiko.RSAKey.from_private_key(io.StringIO(ssh_key))
                  ssh.connect(target, username='ubuntu', pkey=key, timeout=15)
                  print("‚úÖ Connected to EC2-Frontend\n")
                  break
              except Exception as e:
                  if attempt < 2:
                      print(f"‚ö†Ô∏è  Failed, retrying...")
                      time.sleep(10)
                  else:
                      print(f"‚ùå Failed: {e}")
                      exit(1)
          
          commands = [
              ("Stop old frontend", "docker stop frontend-web 2>/dev/null || true"),
              ("Remove old frontend", "docker rm frontend-web 2>/dev/null || true"),
              ("Pull image", f"docker pull {docker_user}/frontend-web:latest"),
              ("Start Frontend", f"""docker run -d --name frontend-web -p 5500:5500 \\
                -e REACT_APP_API_URL='http://{api_ip}:8080' \\
                -e NODE_ENV=production \\
                {docker_user}/frontend-web:latest"""),
              ("Wait", "sleep 5"),
              ("Verify", "docker ps -a -f name=frontend-web --format='table {{.Names}}\\t{{.Status}}'"),
          ]
          
          for desc, cmd in commands:
              print(f"  ‚ñ∂Ô∏è  {desc}...")
              ssh.exec_command(cmd)
              time.sleep(1)
          
          print("\n‚úÖ Frontend deployment complete!\n")
          ssh.close()
          PYTHON

      # =========================================================================
      # STEP 11: DEPLOY EC-BASTION (Bastion Host)
      # =========================================================================
      - name: "üõ°Ô∏è  10/10: Deploy Bastion Host"
        env:
          TARGET_HOST: ${{ steps.config.outputs.bastion_public }}
          DOCKER_USER: ${{ secrets.DOCKER_USERNAME }}
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
        run: |
          python3 << 'PYTHON'
          import paramiko
          import io
          import os
          import time
          
          target = os.environ['TARGET_HOST']
          docker_user = os.environ['DOCKER_USER']
          ssh_key = os.environ['EC2_SSH_KEY']
          
          print(f"\n{'='*70}")
          print(f"üõ°Ô∏è  STEP 10/10: Deploy Bastion Host")
          print(f"{'='*70}\n")
          
          ssh = paramiko.SSHClient()
          ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
          
          for attempt in range(3):
              try:
                  print(f"üîó Connection attempt {attempt + 1}/3...")
                  key = paramiko.RSAKey.from_private_key(io.StringIO(ssh_key))
                  ssh.connect(target, username='ubuntu', pkey=key, timeout=15)
                  print("‚úÖ Connected to EC-Bastion\n")
                  break
              except Exception as e:
                  if attempt < 2:
                      print(f"‚ö†Ô∏è  Failed, retrying...")
                      time.sleep(10)
                  else:
                      print(f"‚ùå Failed: {e}")
                      exit(1)
          
          commands = [
              ("Stop old bastion", "docker stop bastion-host 2>/dev/null || true"),
              ("Remove old bastion", "docker rm bastion-host 2>/dev/null || true"),
              ("Pull image", f"docker pull {docker_user}/bastion-host:latest"),
              ("Start Bastion", f"""docker run -d --name bastion-host -p 22:22 \\
                -e NODE_ENV=production \\
                {docker_user}/bastion-host:latest"""),
              ("Wait", "sleep 5"),
              ("Verify", "docker ps -a -f name=bastion-host --format='table {{.Names}}\\t{{.Status}}'"),
          ]
          
          for desc, cmd in commands:
              print(f"  ‚ñ∂Ô∏è  {desc}...")
              ssh.exec_command(cmd)
              time.sleep(1)
          
          print("\n‚úÖ Bastion deployment complete!\n")
          ssh.close()
          PYTHON

      # =========================================================================
      # FINAL VERIFICATION & TESTING
      # =========================================================================
      - name: "‚úÖ Final Verification & Testing"
        env:
          API_GATEWAY_IP: ${{ steps.config.outputs.api_public }}
          FRONTEND_IP: ${{ steps.config.outputs.frontend_public }}
          MONITORING_IP: ${{ steps.config.outputs.monitoring_public }}
        run: |
          python3 << 'PYTHON'
          import requests
          import time
          import random
          import string
          
          api_ip = "${{ env.API_GATEWAY_IP }}"
          frontend_ip = "${{ env.FRONTEND_IP }}"
          monitoring_ip = "${{ env.MONITORING_IP }}"
          api_url = f"http://{api_ip}:8080"
          
          print(f"\n{'='*70}")
          print(f"‚úÖ FINAL VERIFICATION & TESTING")
          print(f"{'='*70}\n")
          
          tests_passed = 0
          tests_total = 0
          
          # Test 1: API Gateway Health
          tests_total += 1
          print("Test 1Ô∏è‚É£  API Gateway Health")
          try:
              r = requests.get(f"{api_url}/health", timeout=5)
              if r.status_code == 200:
                  print(f"   ‚úÖ {r.status_code} OK\n")
                  tests_passed += 1
              else:
                  print(f"   ‚ö†Ô∏è  {r.status_code}\n")
          except Exception as e:
              print(f"   ‚ùå {str(e)[:50]}\n")
          
          # Test 2: Auth Health
          tests_total += 1
          print("Test 2Ô∏è‚É£  Auth Service Health")
          try:
              r = requests.get(f"{api_url}/auth/health", timeout=5)
              if r.status_code == 200:
                  print(f"   ‚úÖ {r.status_code} OK\n")
                  tests_passed += 1
              else:
                  print(f"   ‚ö†Ô∏è  {r.status_code}\n")
          except Exception as e:
              print(f"   ‚ùå {str(e)[:50]}\n")
          
          # Test 3: Register (CRITICAL MongoDB)
          tests_total += 1
          print("Test 3Ô∏è‚É£  Register Endpoint (CRITICAL)")
          try:
              test_user = {
                  "email": ''.join(random.choices(string.ascii_lowercase, k=10)) + '@test.com',
                  "password": "Test123!",
                  "name": "Test User"
              }
              r = requests.post(f"{api_url}/auth/register", json=test_user, timeout=8)
              if r.status_code == 201:
                  print(f"   ‚úÖ {r.status_code} Created - User registered!\n")
                  tests_passed += 1
              elif r.status_code == 400:
                  print(f"   ‚ö†Ô∏è  {r.status_code} Bad Request\n")
              else:
                  print(f"   ‚ö†Ô∏è  {r.status_code}\n")
          except requests.exceptions.Timeout:
              print(f"   ‚ùå TIMEOUT - MongoDB issue\n")
          except Exception as e:
              print(f"   ‚ùå {str(e)[:100]}\n")
          
          # Summary
          print(f"{'='*70}")
          print(f"üìä FINAL SUMMARY")
          print(f"{'='*70}\n")
          print(f"‚úÖ Tests Passed: {tests_passed}/{tests_total}\n")
          print(f"üìç SERVICE URLS:\n")
          print(f"   üé® Frontend: http://{frontend_ip}:5500")
          print(f"   üåê API Gateway: http://{api_ip}:8080")
          print(f"   üìà Grafana: http://{monitoring_ip}:3000 (admin/admin)")
          print(f"   üìä Prometheus: http://{monitoring_ip}:9090")
          print(f"   üîê RabbitMQ: http://{frontend_ip}:15672 (admin/admin)\n")
          
          PYTHON

      # =========================================================================
      # FINAL REPORT
      # =========================================================================
      - name: "üéâ Deployment Complete!"
        if: success()
        run: |
          echo ""
          echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
          echo "‚ïë                                                                    ‚ïë"
          echo "‚ïë    ‚úÖ COMPLETE INFRASTRUCTURE DEPLOYMENT SUCCESSFUL!              ‚ïë"
          echo "‚ïë                                                                    ‚ïë"
          echo "‚ïë                      üéâ ALL 10 HOSTS READY üéâ                     ‚ïë"
          echo "‚ïë                                                                    ‚ïë"
          echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
          echo ""
          echo "‚úÖ DEPLOYED SERVICES (20+):"
          echo "   EC2-Messaging (3):     Zookeeper, Kafka, RabbitMQ"
          echo "   EC2-DB (3):            MongoDB, PostgreSQL, Redis"
          echo "   EC2-CORE (4):          micro-auth, micro-estudiantes, micro-maestros, micro-core"
          echo "   EC2-API-Gateway (1):   api-gateway"
          echo "   EC2-Analytics (1):     micro-analytics"
          echo "   EC2-Reportes (2):      micro-reportes-estudiantes, micro-reportes-maestros"
          echo "   EC2-Notificaciones (1): micro-notificaciones"
          echo "   EC2-Monitoring (2):    Prometheus, Grafana"
          echo "   EC2-Frontend (1):      frontend-web"
          echo "   EC-Bastion (1):        bastion-host"
          echo ""
          echo "‚úÖ TOTAL: 10 Hosts, 20+ Services, ~120 minutes deployment"
          echo ""

      - name: "‚ùå Deployment Failed"
        if: failure()
        run: |
          echo ""
          echo "‚ùå DEPLOYMENT FAILED"
          echo ""
          echo "Review the logs above for details on which step failed."
          echo ""
